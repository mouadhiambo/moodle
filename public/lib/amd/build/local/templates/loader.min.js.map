{"version":3,"file":"loader.min.js","sources":["../../../src/local/templates/loader.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\nimport $ from 'jquery';\r\nimport ajax from 'core/ajax';\r\nimport * as str from 'core/str';\r\nimport * as config from 'core/config';\r\nimport mustache from 'core/mustache';\r\nimport storage from 'core/localstorage';\r\nimport {getNormalisedComponent} from 'core/utils';\r\n\r\n/**\r\n * Template this.\r\n *\r\n * @module     core/local/templates/loader\r\n * @copyright  2023 Andrew Lyons <andrew@nicols.co.uk>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n * @since      4.3\r\n */\r\nexport default class Loader {\r\n    /** @var {String} themeName for the current render */\r\n    currentThemeName = '';\r\n\r\n    /** @var {Object[]} loadTemplateBuffer - List of templates to be loaded */\r\n    static loadTemplateBuffer = [];\r\n\r\n    /** @var {Bool} isLoadingTemplates - Whether templates are currently being loaded */\r\n    static isLoadingTemplates = false;\r\n\r\n    /** @var {Map} templateCache - Cache of already loaded template strings */\r\n    static templateCache = new Map();\r\n\r\n    /** @var {Promise[]} templatePromises - Cache of already loaded template promises */\r\n    static templatePromises = {};\r\n\r\n    /** @var {Promise[]} cachePartialPromises - Cache of already loaded template partial promises */\r\n    static cachePartialPromises = [];\r\n\r\n    /**\r\n     * A helper to get the search key\r\n     *\r\n     * @param {string} theme\r\n     * @param {string} templateName\r\n     * @returns {string}\r\n     */\r\n    static getSearchKey(theme, templateName) {\r\n        return `${theme}/${templateName}`;\r\n    }\r\n\r\n    /**\r\n     * Load a template.\r\n     *\r\n     * @method getTemplate\r\n     * @param {string} templateName - should consist of the component and the name of the template like this:\r\n     *                              core/menu (lib/templates/menu.mustache) or\r\n     *                              tool_bananas/yellow (admin/tool/bananas/templates/yellow.mustache)\r\n     * @param {string} [themeName=config.theme] - The theme to load the template from\r\n     * @return {Promise} JQuery promise object resolved when the template has been fetched.\r\n     */\r\n    static getTemplate(templateName, themeName = config.theme) {\r\n        const searchKey = this.getSearchKey(themeName, templateName);\r\n\r\n        // If we haven't already seen this template then buffer it.\r\n        const cachedPromise = this.getTemplatePromiseFromCache(searchKey);\r\n        if (cachedPromise) {\r\n            return cachedPromise;\r\n        }\r\n\r\n        // Check the buffer to see if this template has already been added.\r\n        const existingBufferRecords = this.loadTemplateBuffer.filter((record) => record.searchKey === searchKey);\r\n        if (existingBufferRecords.length) {\r\n            // This template is already in the buffer so just return the existing\r\n            // promise. No need to add it to the buffer again.\r\n            return existingBufferRecords[0].deferred.promise();\r\n        }\r\n\r\n        // This is the first time this has been requested so let's add it to the buffer\r\n        // to be loaded.\r\n        const parts = templateName.split('/');\r\n        const component = getNormalisedComponent(parts.shift());\r\n        const name = parts.join('/');\r\n        const deferred = $.Deferred();\r\n\r\n        // Add this template to the buffer to be loaded.\r\n        this.loadTemplateBuffer.push({\r\n            component,\r\n            name,\r\n            theme: themeName,\r\n            searchKey,\r\n            deferred,\r\n        });\r\n\r\n        // We know there is at least one thing in the buffer so kick off a processing run.\r\n        this.processLoadTemplateBuffer();\r\n        return deferred.promise();\r\n    }\r\n\r\n    /**\r\n     * Store a template in the cache.\r\n     *\r\n     * @param {string} searchKey\r\n     * @param {string} templateSource\r\n     */\r\n    static setTemplateInCache(searchKey, templateSource) {\r\n        // Cache all of the dependent templates because we'll need them to render\r\n        // the requested template.\r\n        this.templateCache.set(searchKey, templateSource);\r\n    }\r\n\r\n    /**\r\n     * Fetch a template from the cache.\r\n     *\r\n     * @param {string} searchKey\r\n     * @returns {string}\r\n     */\r\n    static getTemplateFromCache(searchKey) {\r\n        return this.templateCache.get(searchKey);\r\n    }\r\n\r\n    /**\r\n     * Check whether a template is in the cache.\r\n     *\r\n     * @param {string} searchKey\r\n     * @returns {bool}\r\n     */\r\n    static hasTemplateInCache(searchKey) {\r\n        return this.templateCache.has(searchKey);\r\n    }\r\n\r\n    /**\r\n     * Prefetch a set of templates without rendering them.\r\n     *\r\n     * @param {Array} templateNames The list of templates to fetch\r\n     * @param {string} themeName\r\n     */\r\n    static prefetchTemplates(templateNames, themeName) {\r\n        templateNames.forEach((templateName) => this.prefetchTemplate(templateName, themeName));\r\n    }\r\n\r\n    /**\r\n     * Prefetech a sginle template without rendering it.\r\n     *\r\n     * @param {string} templateName\r\n     * @param {string} themeName\r\n     */\r\n    static prefetchTemplate(templateName, themeName) {\r\n        const searchKey = this.getSearchKey(themeName, templateName);\r\n\r\n        // If we haven't already seen this template then buffer it.\r\n        if (this.hasTemplateInCache(searchKey)) {\r\n            return;\r\n        }\r\n\r\n        // Check the buffer to see if this template has already been added.\r\n        const existingBufferRecords = this.loadTemplateBuffer.filter((record) => record.searchKey === searchKey);\r\n\r\n        if (existingBufferRecords.length) {\r\n            // This template is already in the buffer so just return the existing promise.\r\n            // No need to add it to the buffer again.\r\n            return;\r\n        }\r\n\r\n        // This is the first time this has been requested so let's add it to the buffer to be loaded.\r\n        const parts = templateName.split('/');\r\n        const component = getNormalisedComponent(parts.shift());\r\n        const name = parts.join('/');\r\n\r\n        // Add this template to the buffer to be loaded.\r\n        this.loadTemplateBuffer.push({\r\n            component,\r\n            name,\r\n            theme: themeName,\r\n            searchKey,\r\n            deferred: $.Deferred(),\r\n        });\r\n\r\n        this.processLoadTemplateBuffer();\r\n    }\r\n\r\n    /**\r\n     * Load a partial from the cache or ajax.\r\n     *\r\n     * @method partialHelper\r\n     * @param {string} name The partial name to load.\r\n     * @param {string} [themeName = config.theme] The theme to load the partial from.\r\n     * @return {string}\r\n     */\r\n    static partialHelper(name, themeName = config.theme) {\r\n        const searchKey = this.getSearchKey(themeName, name);\r\n\r\n        if (!this.hasTemplateInCache(searchKey)) {\r\n            new Error(`Failed to pre-fetch the template: ${name}`);\r\n        }\r\n        return this.getTemplateFromCache(searchKey);\r\n    }\r\n\r\n    /**\r\n     * Scan a template source for partial tags and return a list of the found partials.\r\n     *\r\n     * @method scanForPartials\r\n     * @param {string} templateSource - source template to scan.\r\n     * @return {Array} List of partials.\r\n     */\r\n    static scanForPartials(templateSource) {\r\n        const tokens = mustache.parse(templateSource);\r\n        const partials = [];\r\n\r\n        const findPartial = (tokens, partials) => {\r\n            let i;\r\n            for (i = 0; i < tokens.length; i++) {\r\n                const token = tokens[i];\r\n                if (token[0] == '>' || token[0] == '<') {\r\n                    partials.push(token[1]);\r\n                }\r\n                if (token.length > 4) {\r\n                    findPartial(token[4], partials);\r\n                }\r\n            }\r\n        };\r\n\r\n        findPartial(tokens, partials);\r\n\r\n        return partials;\r\n    }\r\n\r\n    /**\r\n     * Load a template and scan it for partials. Recursively fetch the partials.\r\n     *\r\n     * @method cachePartials\r\n     * @param {string} templateName - should consist of the component and the name of the template like this:\r\n     *                              core/menu (lib/templates/menu.mustache) or\r\n     *                              tool_bananas/yellow (admin/tool/bananas/templates/yellow.mustache)\r\n     * @param {string} [themeName=config.theme]\r\n     * @param {Array} parentage - A list of requested partials in this render chain.\r\n     * @return {Promise} JQuery promise object resolved when all partials are in the cache.\r\n     */\r\n    static cachePartials(templateName, themeName = config.theme, parentage = []) {\r\n        const searchKey = this.getSearchKey(themeName, templateName);\r\n\r\n        if (searchKey in this.cachePartialPromises) {\r\n            return this.cachePartialPromises[searchKey];\r\n        }\r\n\r\n        // This promise will not be resolved until all child partials are also resolved and ready.\r\n        // We create it here to allow us to check for recursive inclusion of templates.\r\n        // Keep track of the requested partials in this chain.\r\n        if (!parentage.length) {\r\n            parentage.push(searchKey);\r\n        }\r\n\r\n        this.cachePartialPromises[searchKey] = $.Deferred();\r\n        this._cachePartials(templateName, themeName, parentage).catch((error) => {\r\n            this.cachePartialPromises[searchKey].reject(error);\r\n        });\r\n\r\n        return this.cachePartialPromises[searchKey];\r\n    }\r\n\r\n    /**\r\n     * Cache the template partials for the specified template.\r\n     *\r\n     * @param {string} templateName\r\n     * @param {string} themeName\r\n     * @param {array} parentage\r\n     * @returns {promise<string>}\r\n     */\r\n    static async _cachePartials(templateName, themeName, parentage) {\r\n        const searchKey = this.getSearchKey(themeName, templateName);\r\n        const templateSource = await this.getTemplate(templateName, themeName);\r\n        const partials = this.scanForPartials(templateSource);\r\n        const uniquePartials = partials.filter((partialName) => {\r\n            // Check for recursion.\r\n            if (parentage.indexOf(`${themeName}/${partialName}`) >= 0) {\r\n                // Ignore templates which include a parent template already requested in the current chain.\r\n                return false;\r\n            }\r\n\r\n            // Ignore templates that include themselves.\r\n            return partialName !== templateName;\r\n        });\r\n\r\n        // Fetch any partial which has not already been fetched.\r\n        const fetchThemAll = uniquePartials.map((partialName) => {\r\n            parentage.push(`${themeName}/${partialName}`);\r\n            return this.cachePartials(partialName, themeName, parentage);\r\n        });\r\n\r\n        await Promise.all(fetchThemAll);\r\n        return this.cachePartialPromises[searchKey].resolve(templateSource);\r\n    }\r\n\r\n    /**\r\n     * Take all of the templates waiting in the buffer and load them from the server\r\n     * or from the cache.\r\n     *\r\n     * All of the templates that need to be loaded from the server will be batched up\r\n     * and sent in a single network request.\r\n     */\r\n    static processLoadTemplateBuffer() {\r\n        if (!this.loadTemplateBuffer.length) {\r\n            return;\r\n        }\r\n\r\n        if (this.isLoadingTemplates) {\r\n            return;\r\n        }\r\n\r\n        this.isLoadingTemplates = true;\r\n        // Grab any templates waiting in the buffer.\r\n        const templatesToLoad = this.loadTemplateBuffer.slice();\r\n        // This will be resolved with the list of promises for the server request.\r\n        const serverRequestsDeferred = $.Deferred();\r\n        const requests = [];\r\n        // Get a list of promises for each of the templates we need to load.\r\n        const templatePromises = templatesToLoad.map((templateData) => {\r\n            const component = getNormalisedComponent(templateData.component);\r\n            const name = templateData.name;\r\n            const searchKey = templateData.searchKey;\r\n            const theme = templateData.theme;\r\n            const templateDeferred = templateData.deferred;\r\n            let promise = null;\r\n\r\n            // Double check to see if this template happened to have landed in the\r\n            // cache as a dependency of an earlier template.\r\n            if (this.hasTemplateInCache(searchKey)) {\r\n                // We've seen this template so immediately resolve the existing promise.\r\n                promise = this.getTemplatePromiseFromCache(searchKey);\r\n            } else {\r\n                // We haven't seen this template yet so we need to request it from\r\n                // the server.\r\n                requests.push({\r\n                    methodname: 'core_output_load_template_with_dependencies',\r\n                    args: {\r\n                        component,\r\n                        template: name,\r\n                        themename: theme,\r\n                        lang: config.language,\r\n                    }\r\n                });\r\n                // Remember the index in the requests list for this template so that\r\n                // we can get the appropriate promise back.\r\n                const index = requests.length - 1;\r\n\r\n                // The server deferred will be resolved with a list of all of the promises\r\n                // that were sent in the order that they were added to the requests array.\r\n                promise = serverRequestsDeferred.promise()\r\n                    .then((promises) => {\r\n                        // The promise for this template will be the one that matches the index\r\n                        // for it's entry in the requests array.\r\n                        //\r\n                        // Make sure the promise is added to the promises cache for this template\r\n                        // search key so that we don't request it again.\r\n                        templatePromises[searchKey] = promises[index].then((response) => {\r\n                            // Process all of the template dependencies for this template and add\r\n                            // them to the caches so that we don't request them again later.\r\n                            response.templates.forEach((data) => {\r\n                                data.component = getNormalisedComponent(data.component);\r\n                                const tempSearchKey = this.getSearchKey(\r\n                                    theme,\r\n                                    [data.component, data.name].join('/'),\r\n                                );\r\n\r\n                                // Cache all of the dependent templates because we'll need them to render\r\n                                // the requested template.\r\n                                this.setTemplateInCache(tempSearchKey, data.value);\r\n\r\n                                if (config.templaterev > 0) {\r\n                                    // The template cache is enabled - set the value there.\r\n                                    storage.set(`core_template/${config.templaterev}:${tempSearchKey}`, data.value);\r\n                                }\r\n                            });\r\n\r\n                            if (response.strings.length) {\r\n                                // If we have strings that the template needs then warm the string cache\r\n                                // with them now so that we don't need to re-fetch them.\r\n                                str.cache_strings(response.strings.map(({component, name, value}) => ({\r\n                                    component: getNormalisedComponent(component),\r\n                                    key: name,\r\n                                    value,\r\n                                })));\r\n                            }\r\n\r\n                            // Return the original template source that the user requested.\r\n                            if (this.hasTemplateInCache(searchKey)) {\r\n                                return this.getTemplateFromCache(searchKey);\r\n                            }\r\n\r\n                            return null;\r\n                        });\r\n\r\n                        return templatePromises[searchKey];\r\n                    });\r\n            }\r\n\r\n            return promise\r\n                // When we've successfully loaded the template then resolve the deferred\r\n                // in the buffer so that all of the calling code can proceed.\r\n                .then((source) => templateDeferred.resolve(source))\r\n                .catch((error) => {\r\n                    // If there was an error loading the template then reject the deferred\r\n                    // in the buffer so that all of the calling code can proceed.\r\n                    templateDeferred.reject(error);\r\n                    // Rethrow for anyone else listening.\r\n                    throw error;\r\n                });\r\n        });\r\n\r\n        if (requests.length) {\r\n            // We have requests to send so resolve the deferred with the promises.\r\n            serverRequestsDeferred.resolve(ajax.call(requests, true, false, false, 0, config.templaterev));\r\n        } else {\r\n            // Nothing to load so we can resolve our deferred.\r\n            serverRequestsDeferred.resolve();\r\n        }\r\n\r\n        // Once we've finished loading all of the templates then recurse to process\r\n        // any templates that may have been added to the buffer in the time that we\r\n        // were fetching.\r\n        $.when.apply(null, templatePromises)\r\n            .then(() => {\r\n                // Remove the templates we've loaded from the buffer.\r\n                this.loadTemplateBuffer.splice(0, templatesToLoad.length);\r\n                this.isLoadingTemplates = false;\r\n                this.processLoadTemplateBuffer();\r\n                return;\r\n            })\r\n            .catch(() => {\r\n                // Remove the templates we've loaded from the buffer.\r\n                this.loadTemplateBuffer.splice(0, templatesToLoad.length);\r\n                this.isLoadingTemplates = false;\r\n                this.processLoadTemplateBuffer();\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Search the various caches for a template promise for the given search key.\r\n     * The search key should be in the format <theme>/<component>/<template> e.g. boost/core/modal.\r\n     *\r\n     * If the template is found in any of the caches it will populate the other caches with\r\n     * the same data as well.\r\n     *\r\n     * @param {String} searchKey The template search key in the format <theme>/<component>/<template> e.g. boost/core/modal\r\n     * @returns {Object|null} jQuery promise resolved with the template source\r\n     */\r\n    static getTemplatePromiseFromCache(searchKey) {\r\n        // First try the cache of promises.\r\n        if (searchKey in this.templatePromises) {\r\n            return this.templatePromises[searchKey];\r\n        }\r\n\r\n        // Check the module cache.\r\n        if (this.hasTemplateInCache(searchKey)) {\r\n            const templateSource = this.getTemplateFromCache(searchKey);\r\n            // Add this to the promises cache for future.\r\n            this.templatePromises[searchKey] = $.Deferred().resolve(templateSource).promise();\r\n            return this.templatePromises[searchKey];\r\n        }\r\n\r\n        if (config.templaterev <= 0) {\r\n            // Template caching is disabled. Do not store in persistent storage.\r\n            return null;\r\n        }\r\n\r\n        // Now try local storage.\r\n        const cached = storage.get(`core_template/${config.templaterev}:${searchKey}`);\r\n        if (cached) {\r\n            // Add this to the module cache for future.\r\n            this.setTemplateInCache(searchKey, cached);\r\n\r\n            // Add to the promises cache for future.\r\n            this.templatePromises[searchKey] = $.Deferred().resolve(cached).promise();\r\n            return this.templatePromises[searchKey];\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n"],"names":["Loader","theme","templateName","themeName","config","searchKey","this","getSearchKey","cachedPromise","getTemplatePromiseFromCache","existingBufferRecords","loadTemplateBuffer","filter","record","length","deferred","promise","parts","split","component","shift","name","join","$","Deferred","push","processLoadTemplateBuffer","templateSource","templateCache","set","get","has","templateNames","forEach","prefetchTemplate","hasTemplateInCache","Error","getTemplateFromCache","tokens","mustache","parse","partials","findPartial","i","token","parentage","cachePartialPromises","_cachePartials","catch","error","reject","getTemplate","fetchThemAll","scanForPartials","partialName","indexOf","map","cachePartials","Promise","all","resolve","isLoadingTemplates","templatesToLoad","slice","serverRequestsDeferred","requests","templatePromises","templateData","templateDeferred","methodname","args","template","themename","lang","language","index","then","promises","response","templates","data","tempSearchKey","setTemplateInCache","value","templaterev","strings","str","cache_strings","_ref","key","source","ajax","call","when","apply","splice","cached","storage","Map"],"mappings":"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"}