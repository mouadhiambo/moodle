{"version":3,"file":"dragdrop.min.js","sources":["../../../src/local/reactive/dragdrop.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Drag and drop helper component.\r\n *\r\n * This component is used to delegate drag and drop handling.\r\n *\r\n * To delegate the logic to this particular element the component should create a new instance\r\n * passing \"this\" as param. The component will use all the necessary callbacks and add all the\r\n * necessary listeners to the component element.\r\n *\r\n * Component attributes used by dragdrop module:\r\n * - element: the draggable or dropzone element.\r\n * - (optional) classes: object with alternative CSS classes\r\n * - (optional) fullregion: page element affeted by the elementy dragging. Use this attribute if\r\n *                          the draggable element affects a bigger region (for example a draggable\r\n *                          title).\r\n * - (optional) autoconfigDraggable: by default, the component will be draggable if it has a\r\n *                                   getDraggableData method. If this value is false draggable\r\n *                                  property must be defined using setDraggable method.\r\n * - (optional) relativeDrag: by default the drag image is located at point (0,0) relative to the\r\n *                            mouse position to prevent the mouse from covering it. If this attribute\r\n *                            is true the drag image will be located at the click offset.\r\n *\r\n * Methods the parent component should have for making it draggable:\r\n *\r\n * - getDraggableData(): Object|data\r\n *      Return the data that will be passed to any valid dropzone while it is dragged.\r\n *      If the component has this method, the dragdrop module will enable the dragging,\r\n *      this is the only required method for dragging.\r\n *      If at the dragging moment this method returns a false|null|undefined, the dragging\r\n *      actions won't be captured.\r\n *\r\n * - (optional) dragStart(Object dropdata, Event event): void\r\n * - (optional) dragEnd(Object dropdata, Event event): void\r\n *      Callbacks dragdrop will call when the element is dragged and getDraggableData\r\n *      return some data.\r\n *\r\n * Methods the parent component should have for enabling it as a dropzone:\r\n *\r\n * - validateDropData(Object dropdata): boolean\r\n *      If that method exists, the dragdrop module will automathically configure the element as dropzone.\r\n *      This method will return true if the dropdata is accepted. In case it returns false, no drag and\r\n *      drop event will be listened for this specific dragged dropdata.\r\n *\r\n * - (Optional) showDropZone(Object dropdata, Event event): void\r\n * - (Optional) hideDropZone(Object dropdata, Event event): void\r\n *      Methods called when a valid dragged data pass over the element.\r\n *\r\n * - (Optional) drop(Object dropdata, Event event): void\r\n *      Called when a valid dragged element is dropped over the element.\r\n *\r\n *      Note that none of this methods will be called if validateDropData\r\n *      returns a false value.\r\n *\r\n * This module will also add or remove several CSS classes from both dragged elements and dropzones.\r\n * See the \"this.classes\" in the create method for more details. In case the parent component wants\r\n * to use the same classes, it can use the getClasses method. On the other hand, if the parent\r\n * component has an alternative \"classes\" attribute, this will override the default drag and drop\r\n * classes.\r\n *\r\n * @module     core/local/reactive/dragdrop\r\n * @class      core/local/reactive/dragdrop\r\n * @copyright  2021 Ferran Recio <ferran@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\nimport BaseComponent from 'core/local/reactive/basecomponent';\r\n\r\n// Map with the dragged element generate by an specific reactive applications.\r\n// Potentially, any component can generate a draggable element to interact with other\r\n// page elements. However, the dragged data is specific and could only interact with\r\n// components of the same reactive instance.\r\nlet activeDropData = new Map();\r\n\r\n// Drag & Drop API provides the final drop point and incremental movements but we can\r\n// provide also starting points and displacements. Absolute displacements simplifies\r\n// moving components with aboslute position around the page.\r\nlet dragStartPoint = {};\r\n\r\nexport default class extends BaseComponent {\r\n\r\n    /**\r\n     * Constructor hook.\r\n     *\r\n     * @param {BaseComponent} parent the parent component.\r\n     */\r\n    create(parent) {\r\n        // Optional component name for debugging.\r\n        this.name = `${parent.name ?? 'unkown'}_dragdrop`;\r\n\r\n        // Default drag and drop classes.\r\n        this.classes = Object.assign(\r\n                {\r\n                // This class indicate a dragging action is active at a page level.\r\n                BODYDRAGGING: 'dragging',\r\n\r\n                // Added when draggable and drop are ready.\r\n                DRAGGABLEREADY: 'draggable',\r\n                DROPREADY: 'dropready',\r\n\r\n                // When a valid drag element is over the element.\r\n                DRAGOVER: 'dragover',\r\n                // When a the component is dragged.\r\n                DRAGGING: 'dragging',\r\n\r\n                // Dropzones classes names.\r\n                DROPUP: 'drop-up',\r\n                DROPDOWN: 'drop-down',\r\n                DROPZONE: 'drop-zone',\r\n\r\n                // Drag icon class.\r\n                DRAGICON: 'dragicon',\r\n            },\r\n            parent?.classes ?? {}\r\n        );\r\n\r\n        // Add the affected region if any.\r\n        this.fullregion = parent.fullregion;\r\n\r\n        // Keep parent to execute drap and drop handlers.\r\n        this.parent = parent;\r\n\r\n        // Check if parent handle draggable manually.\r\n        this.autoconfigDraggable = this.parent.draggable ?? true;\r\n\r\n        // Drag image relative position.\r\n        this.relativeDrag = this.parent.relativeDrag ?? false;\r\n\r\n        // Sub HTML elements will trigger extra dragEnter and dragOver all the time.\r\n        // To prevent that from affecting dropzones, we need to count the enters and leaves.\r\n        this.entercount = 0;\r\n\r\n        // Stores if the droparea is shown or not.\r\n        this.dropzonevisible = false;\r\n\r\n        // Stores if the mouse is over the element or not.\r\n        this.ismouseover = false;\r\n    }\r\n\r\n    /**\r\n     * Return the component drag and drop CSS classes.\r\n     *\r\n     * @returns {Object} the dragdrop css classes\r\n     */\r\n    getClasses() {\r\n        return this.classes;\r\n    }\r\n\r\n    /**\r\n     * Return the current drop-zone visible of the element.\r\n     *\r\n     * @returns {boolean} if the dropzone should be visible or not\r\n     */\r\n    isDropzoneVisible() {\r\n        return this.dropzonevisible;\r\n    }\r\n\r\n    /**\r\n     * Initial state ready method.\r\n     *\r\n     * This method will add all the necessary event listeners to the component depending on the\r\n     * parent methods.\r\n     *  - Add drop events to the element if the parent component has validateDropData method.\r\n     *  - Configure the elements draggable if the parent component has getDraggableData method.\r\n     */\r\n    stateReady() {\r\n        // Add drop events to the element if the parent component has dropable types.\r\n        if (typeof this.parent.validateDropData === 'function') {\r\n            this.element.classList.add(this.classes.DROPREADY);\r\n            this.addEventListener(this.element, 'dragenter', this._dragEnter);\r\n            this.addEventListener(this.element, 'dragleave', this._dragLeave);\r\n            this.addEventListener(this.element, 'dragover', this._dragOver);\r\n            this.addEventListener(this.element, 'drop', this._drop);\r\n            this.addEventListener(this.element, 'mouseover', this._mouseOver);\r\n            this.addEventListener(this.element, 'mouseleave', this._mouseLeave);\r\n        }\r\n\r\n        // Configure the elements draggable if the parent component has dragable data.\r\n        if (this.autoconfigDraggable && typeof this.parent.getDraggableData === 'function') {\r\n            this.setDraggable(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enable or disable the draggable property.\r\n     *\r\n     * @param {bool} value the new draggable value\r\n     */\r\n    setDraggable(value) {\r\n        if (typeof this.parent.getDraggableData !== 'function') {\r\n            throw new Error(`Draggable components must have a getDraggableData method`);\r\n        }\r\n        this.element.setAttribute('draggable', value);\r\n        if (value) {\r\n            this.addEventListener(this.element, 'dragstart', this._dragStart);\r\n            this.addEventListener(this.element, 'dragend', this._dragEnd);\r\n            this.element.classList.add(this.classes.DRAGGABLEREADY);\r\n        } else {\r\n            this.removeEventListener(this.element, 'dragstart', this._dragStart);\r\n            this.removeEventListener(this.element, 'dragend', this._dragEnd);\r\n            this.element.classList.remove(this.classes.DRAGGABLEREADY);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Mouse over handle.\r\n     */\r\n    _mouseOver() {\r\n        this.ismouseover = true;\r\n    }\r\n\r\n    /**\r\n     * Mouse leave handler.\r\n     */\r\n    _mouseLeave() {\r\n        this.ismouseover = false;\r\n    }\r\n\r\n    /**\r\n     * Drag start event handler.\r\n     *\r\n     * This method will generate the current dropable data. This data is the one used to determine\r\n     * if a droparea accepts the dropping or not.\r\n     *\r\n     * @param {Event} event the event.\r\n     */\r\n    _dragStart(event) {\r\n        // Cancel dragging if any editable form element is focussed.\r\n        if (document.activeElement.matches(`textarea, input`)) {\r\n            event.preventDefault();\r\n            return;\r\n        }\r\n\r\n        const dropdata = this.parent.getDraggableData();\r\n        if (!dropdata) {\r\n            return;\r\n        }\r\n\r\n        // Save the starting point.\r\n        dragStartPoint = {\r\n            pageX: event.pageX,\r\n            pageY: event.pageY,\r\n        };\r\n\r\n        // If the drag event is accepted we prevent any other draggable element from interfiering.\r\n        event.stopPropagation();\r\n\r\n        // Save the drop data of the current reactive intance.\r\n        activeDropData.set(this.reactive, dropdata);\r\n\r\n        // Add some CSS classes to indicate the state.\r\n        document.body.classList.add(this.classes.BODYDRAGGING);\r\n        this.element.classList.add(this.classes.DRAGGING);\r\n        this.fullregion?.classList.add(this.classes.DRAGGING);\r\n\r\n        // Force the drag image. This makes the UX more consistent in case the\r\n        // user dragged an internal element like a link or some other element.\r\n        let dragImage = this.element;\r\n        if (this.parent.setDragImage !== undefined) {\r\n            const customImage = this.parent.setDragImage(dropdata, event);\r\n            if (customImage) {\r\n                dragImage = customImage;\r\n            }\r\n        }\r\n        // Define the image position relative to the mouse.\r\n        const position = {x: 0, y: 0};\r\n        if (this.relativeDrag) {\r\n            position.x = event.offsetX;\r\n            position.y = event.offsetY;\r\n        }\r\n        event.dataTransfer.setDragImage(dragImage, position.x, position.y);\r\n        event.dataTransfer.effectAllowed = 'copyMove';\r\n        this._callParentMethod('dragStart', dropdata, event);\r\n    }\r\n\r\n    /**\r\n     * Drag end event handler.\r\n     *\r\n     * @param {Event} event the event.\r\n     */\r\n    _dragEnd(event) {\r\n        const dropdata = activeDropData.get(this.reactive);\r\n        if (!dropdata) {\r\n            return;\r\n        }\r\n\r\n        // Remove the current dropdata.\r\n        activeDropData.delete(this.reactive);\r\n\r\n        // Remove the dragging classes.\r\n        document.body.classList.remove(this.classes.BODYDRAGGING);\r\n        this.element.classList.remove(this.classes.DRAGGING);\r\n        this.fullregion?.classList.remove(this.classes.DRAGGING);\r\n        this.removeAllOverlays();\r\n\r\n        // We add the total movement to the event in case the component\r\n        // wants to move its absolute position.\r\n        this._addEventTotalMovement(event);\r\n\r\n        this._callParentMethod('dragEnd', dropdata, event);\r\n    }\r\n\r\n    /**\r\n     * Drag enter event handler.\r\n     *\r\n     * The JS drag&drop API triggers several dragenter events on the same element because it bubbles the\r\n     * child events as well. To prevent this form affecting the dropzones display, this methods use\r\n     * \"entercount\" to determine if it's one extra child event or a valid one.\r\n     *\r\n     * @param {Event} event the event.\r\n     */\r\n    _dragEnter(event) {\r\n        const dropdata = this._processEvent(event);\r\n        if (dropdata) {\r\n            this.entercount++;\r\n            this.element.classList.add(this.classes.DRAGOVER);\r\n            if (this.entercount == 1 && !this.dropzonevisible) {\r\n                this.dropzonevisible = true;\r\n                this.element.classList.add(this.classes.DRAGOVER);\r\n                this._callParentMethod('showDropZone', dropdata, event);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Drag over event handler.\r\n     *\r\n     * We only use dragover event when a draggable action starts inside a valid dropzone. In those cases\r\n     * the API won't trigger any dragEnter because the dragged alement was already there. We use the\r\n     * dropzonevisible to determine if the component needs to display the dropzones or not.\r\n     *\r\n     * @param {Event} event the event.\r\n     */\r\n    _dragOver(event) {\r\n        const dropdata = this._processEvent(event);\r\n        if (dropdata && !this.dropzonevisible) {\r\n            event.dataTransfer.dropEffect = (event.altKey) ? 'copy' : 'move';\r\n            this.dropzonevisible = true;\r\n            this.element.classList.add(this.classes.DRAGOVER);\r\n            this._callParentMethod('showDropZone', dropdata, event);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Drag over leave handler.\r\n     *\r\n     * The JS drag&drop API triggers several dragleave events on the same element because it bubbles the\r\n     * child events as well. To prevent this form affecting the dropzones display, this methods use\r\n     * \"entercount\" to determine if it's one extra child event or a valid one.\r\n     *\r\n     * @param {Event} event the event.\r\n     */\r\n    _dragLeave(event) {\r\n        const dropdata = this._processEvent(event);\r\n        if (dropdata) {\r\n            this.entercount--;\r\n            if (this.entercount <= 0 && this.dropzonevisible) {\r\n                this.dropzonevisible = false;\r\n                this.element.classList.remove(this.classes.DRAGOVER);\r\n                this._callParentMethod('hideDropZone', dropdata, event);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Drop event handler.\r\n     *\r\n     * This method will call both hideDropZones and drop methods on the parent component.\r\n     *\r\n     * @param {Event} event the event.\r\n     */\r\n    _drop(event) {\r\n        const dropdata = this._processEvent(event);\r\n        if (dropdata) {\r\n            this.entercount = 0;\r\n            if (this.dropzonevisible) {\r\n                this.dropzonevisible = false;\r\n                this._callParentMethod('hideDropZone', dropdata, event);\r\n            }\r\n            this.element.classList.remove(this.classes.DRAGOVER);\r\n            this.removeAllOverlays();\r\n            this._callParentMethod('drop', dropdata, event);\r\n            // An accepted drop resets the initial position.\r\n            // Save the starting point.\r\n            dragStartPoint = {};\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process a drag and drop event and delegate logic to the parent component.\r\n     *\r\n     * @param {Event} event the drag and drop event\r\n     * @return {Object|false} the dropdata or null if the event should not be processed\r\n     */\r\n    _processEvent(event) {\r\n        const dropdata = this._getDropData(event);\r\n        if (!dropdata) {\r\n            return null;\r\n        }\r\n        if (this.parent.validateDropData(dropdata)) {\r\n            // All accepted drag&drop event must prevent bubbling and defaults, otherwise\r\n            // parent dragdrop instances could capture it by mistake.\r\n            event.preventDefault();\r\n            event.stopPropagation();\r\n            this._addEventTotalMovement(event);\r\n            return dropdata;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Add the total amout of movement to a mouse event.\r\n     *\r\n     * @param {MouseEvent} event\r\n     */\r\n    _addEventTotalMovement(event) {\r\n        if (dragStartPoint.pageX === undefined || event.pageX === undefined) {\r\n            return;\r\n        }\r\n        event.fixedMovementX = event.pageX - dragStartPoint.pageX;\r\n        event.fixedMovementY = event.pageY - dragStartPoint.pageY;\r\n        event.initialPageX = dragStartPoint.pageX;\r\n        event.initialPageY = dragStartPoint.pageY;\r\n        // The element possible new top.\r\n        const current = this.element.getBoundingClientRect();\r\n        // Add the new position fixed position.\r\n        event.newFixedTop = current.top + event.fixedMovementY;\r\n        event.newFixedLeft = current.left + event.fixedMovementX;\r\n        // The affected region possible new top.\r\n        if (this.fullregion !== undefined) {\r\n            const current = this.fullregion.getBoundingClientRect();\r\n            event.newRegionFixedxTop = current.top + event.fixedMovementY;\r\n            event.newRegionFixedxLeft = current.left + event.fixedMovementX;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convenient method for calling parent component functions if present.\r\n     *\r\n     * @param {string} methodname the name of the method\r\n     * @param {Object} dropdata the current drop data object\r\n     * @param {Event} event the original event\r\n     */\r\n    _callParentMethod(methodname, dropdata, event) {\r\n        if (typeof this.parent[methodname] === 'function') {\r\n            this.parent[methodname](dropdata, event);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the current dropdata for a specific event.\r\n     *\r\n     * The browser can generate drag&drop events related to several user interactions:\r\n     *  - Drag a page elements: this case is registered in the activeDropData map\r\n     *  - Drag some HTML selections: ignored for now\r\n     *  - Drag a file over the browser: file drag may appear in the future but for now they are ignored.\r\n     *\r\n     * @param {Event} event the original event.\r\n     * @returns {Object|undefined} with the dragged data (or undefined if none)\r\n     */\r\n    _getDropData(event) {\r\n        this._isOnlyFilesDragging = this._containsOnlyFiles(event);\r\n        if (this._isOnlyFilesDragging) {\r\n            // Check if the reactive instance can provide a files draggable data.\r\n            if (this.reactive.getFilesDraggableData !== undefined && typeof this.reactive.getFilesDraggableData === 'function') {\r\n                return this.reactive.getFilesDraggableData(event.dataTransfer);\r\n            }\r\n            return undefined;\r\n        }\r\n        return activeDropData.get(this.reactive);\r\n    }\r\n\r\n    /**\r\n     * Check if the dragged event contains only files.\r\n     *\r\n     * Files dragging does not generate drop data because they came from outside the page and the component\r\n     * must check it before validating the event.\r\n     *\r\n     * Some browsers like Firefox add extra types to file dragging. To discard the false positives\r\n     * a double check is necessary.\r\n     *\r\n     * @param {Event} event the original event.\r\n     * @returns {boolean} if the drag dataTransfers contains files.\r\n     */\r\n    _containsOnlyFiles(event) {\r\n        if (!event.dataTransfer.types.includes('Files')) {\r\n            return false;\r\n        }\r\n        return event.dataTransfer.types.every((type) => {\r\n            return (type.toLowerCase() != 'text/uri-list'\r\n                && type.toLowerCase() != 'text/html'\r\n                && type.toLowerCase() != 'text/plain'\r\n            );\r\n        });\r\n    }\r\n}\r\n"],"names":["activeDropData","Map","dragStartPoint","BaseComponent","create","parent","name","classes","Object","assign","BODYDRAGGING","DRAGGABLEREADY","DROPREADY","DRAGOVER","DRAGGING","DROPUP","DROPDOWN","DROPZONE","DRAGICON","fullregion","autoconfigDraggable","this","draggable","relativeDrag","entercount","dropzonevisible","ismouseover","getClasses","isDropzoneVisible","stateReady","validateDropData","element","classList","add","addEventListener","_dragEnter","_dragLeave","_dragOver","_drop","_mouseOver","_mouseLeave","getDraggableData","setDraggable","value","Error","setAttribute","_dragStart","_dragEnd","removeEventListener","remove","event","document","activeElement","matches","preventDefault","dropdata","pageX","pageY","stopPropagation","set","reactive","body","dragImage","undefined","setDragImage","customImage","position","x","y","offsetX","offsetY","dataTransfer","effectAllowed","_callParentMethod","get","delete","removeAllOverlays","_addEventTotalMovement","_processEvent","dropEffect","altKey","_getDropData","fixedMovementX","fixedMovementY","initialPageX","initialPageY","current","getBoundingClientRect","newFixedTop","top","newFixedLeft","left","newRegionFixedxTop","newRegionFixedxLeft","methodname","_isOnlyFilesDragging","_containsOnlyFiles","getFilesDraggableData","types","includes","every","type","toLowerCase"],"mappings":"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"}