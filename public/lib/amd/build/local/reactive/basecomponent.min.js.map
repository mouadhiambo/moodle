{"version":3,"file":"basecomponent.min.js","sources":["../../../src/local/reactive/basecomponent.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\nimport Templates from 'core/templates';\r\nimport {addOverlay, removeOverlay, removeAllOverlays} from 'core/local/reactive/overlay';\r\n\r\n/**\r\n * Reactive UI component base class.\r\n *\r\n * Each UI reactive component should extend this class to interact with a reactive state.\r\n *\r\n * @module     core/local/reactive/basecomponent\r\n * @class     core/local/reactive/basecomponent\r\n * @copyright  2020 Ferran Recio <ferran@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\nexport default class {\r\n\r\n    /**\r\n     * The component descriptor data structure.\r\n     *\r\n     * This structure is used by any component and init method to define the way the component will interact\r\n     * with the interface and whith reactive instance operates. The logic behind this object is to avoid\r\n     * unnecessary dependancies between the final interface and the state logic.\r\n     *\r\n     * Any component interacts with a single main DOM element (description.element) but it can use internal\r\n     * selector to select elements within this main element (descriptor.selectors). By default each component\r\n     * will provide it's own default selectors, but those can be overridden by the \"descriptor.selectors\"\r\n     * property in case the mustache wants to reuse the same component logic but with a different interface.\r\n     *\r\n     * @typedef {object} descriptor\r\n     * @property {Reactive} reactive an optional reactive module to register in\r\n     * @property {DOMElement} element all components needs an element to anchor events\r\n     * @property {object} [selectors] an optional object to override query selectors\r\n     */\r\n\r\n    /**\r\n     * The class constructor.\r\n     *\r\n     * The only param this method gets is a constructor with all the mandatory\r\n     * and optional component data. Component will receive the same descriptor\r\n     * as create method param.\r\n     *\r\n     * This method will call the \"create\" method before registering the component into\r\n     * the reactive module. This way any component can add default selectors and events.\r\n     *\r\n     * @param {descriptor} descriptor data to create the object.\r\n     */\r\n    constructor(descriptor) {\r\n\r\n        if (descriptor.element === undefined || !(descriptor.element instanceof HTMLElement)) {\r\n            throw Error(`Reactive components needs a main DOM element to dispatch events`);\r\n        }\r\n\r\n        this.element = descriptor.element;\r\n\r\n        // Variable to track event listeners.\r\n        this.eventHandlers = new Map([]);\r\n        this.eventListeners = [];\r\n\r\n        // Empty default component selectors.\r\n        this.selectors = {};\r\n\r\n        // Empty default event list from the static method.\r\n        this.events = this.constructor.getEvents();\r\n\r\n        // Call create function to get the component defaults.\r\n        this.create(descriptor);\r\n\r\n        // Overwrite the components selectors if necessary.\r\n        if (descriptor.selectors !== undefined) {\r\n            this.addSelectors(descriptor.selectors);\r\n        }\r\n\r\n        // Register into a reactive instance.\r\n        if (descriptor.reactive === undefined) {\r\n            // Ask parent components for registration.\r\n            this.element.dispatchEvent(new CustomEvent(\r\n                'core/reactive:requestRegistration',\r\n                {\r\n                    bubbles: true,\r\n                    detail: {component: this},\r\n                }\r\n            ));\r\n        } else {\r\n            this.reactive = descriptor.reactive;\r\n            this.reactive.registerComponent(this);\r\n            // Add a listener to register child components.\r\n            this.addEventListener(\r\n                this.element,\r\n                'core/reactive:requestRegistration',\r\n                (event) => {\r\n                    if (event?.detail?.component) {\r\n                        event.stopPropagation();\r\n                        this.registerChildComponent(event.detail.component);\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the component custom event names.\r\n     *\r\n     * Components may override this method to provide their own events.\r\n     *\r\n     * Component custom events is an important part of component reusability. This function\r\n     * is static because is part of the component definition and should be accessible from\r\n     * outsite the instances. However, values will be available at instance level in the\r\n     * this.events object.\r\n     *\r\n     * @returns {Object} the component events.\r\n     */\r\n    static getEvents() {\r\n        return {};\r\n    }\r\n\r\n    /**\r\n     * Component create function.\r\n     *\r\n     * Default init method will call \"create\" when all internal attributes are set\r\n     * but before the component is not yet registered in the reactive module.\r\n     *\r\n     * In this method any component can define its own defaults such as:\r\n     * - this.selectors {object} the default query selectors of this component.\r\n     * - this.events {object} a list of event names this component dispatch\r\n     * - extract any data from the main dom element (this.element)\r\n     * - set any other data the component uses\r\n     *\r\n     * @param {descriptor} descriptor the component descriptor\r\n     */\r\n    // eslint-disable-next-line no-unused-vars\r\n    create(descriptor) {\r\n        // Components may override this method to initialize selects, events or other data.\r\n    }\r\n\r\n    /**\r\n     * Component destroy hook.\r\n     *\r\n     * BaseComponent call this method when a component is unregistered or removed.\r\n     *\r\n     * Components may override this method to clean the HTML or do some action when the\r\n     * component is unregistered or removed.\r\n     */\r\n    destroy() {\r\n        // Components can override this method.\r\n    }\r\n\r\n    /**\r\n     * Return the list of watchers that component has.\r\n     *\r\n     * Each watcher is represented by an object with two attributes:\r\n     * - watch (string) the specific state event to watch. Example 'section.visible:updated'\r\n     * - handler (function) the function to call when the watching state change happens\r\n     *\r\n     * Any component shoudl override this method to define their state watchers.\r\n     *\r\n     * @returns {array} array of watchers.\r\n     */\r\n    getWatchers() {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Reactive module will call this method when the state is ready.\r\n     *\r\n     * Component can override this method to update/load the component HTML or to bind\r\n     * listeners to HTML entities.\r\n     */\r\n    stateReady() {\r\n        // Components can override this method.\r\n    }\r\n\r\n    /**\r\n     * Get the main DOM element of this component or a subelement.\r\n     *\r\n     * @param {string|undefined} query optional subelement query\r\n     * @param {string|undefined} dataId optional data-id value\r\n     * @returns {element|undefined} the DOM element (if any)\r\n     */\r\n    getElement(query, dataId) {\r\n        if (query === undefined && dataId === undefined) {\r\n            return this.element;\r\n        }\r\n        const dataSelector = (dataId) ? `[data-id='${dataId}']` : '';\r\n        const selector = `${query ?? ''}${dataSelector}`;\r\n        return this.element.querySelector(selector);\r\n    }\r\n\r\n    /**\r\n     * Get the all subelement that match a query selector.\r\n     *\r\n     * @param {string|undefined} query optional subelement query\r\n     * @param {string|undefined} dataId optional data-id value\r\n     * @returns {NodeList} the DOM elements\r\n     */\r\n    getElements(query, dataId) {\r\n        const dataSelector = (dataId) ? `[data-id='${dataId}']` : '';\r\n        const selector = `${query ?? ''}${dataSelector}`;\r\n        return this.element.querySelectorAll(selector);\r\n    }\r\n\r\n    /**\r\n     * Add or update the component selectors.\r\n     *\r\n     * @param {Object} newSelectors an object of new selectors.\r\n     */\r\n    addSelectors(newSelectors) {\r\n        for (const [selectorName, selector] of Object.entries(newSelectors)) {\r\n            this.selectors[selectorName] = selector;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return a component selector.\r\n     *\r\n     * @param {string} selectorName the selector name\r\n     * @return {string|undefined} the query selector\r\n     */\r\n    getSelector(selectorName) {\r\n        return this.selectors[selectorName];\r\n    }\r\n\r\n    /**\r\n     * Dispatch a custom event on this.element.\r\n     *\r\n     * This is just a convenient method to dispatch custom events from within a component.\r\n     * Components are free to use an alternative function to dispatch custom\r\n     * events. The only restriction is that it should be dispatched on this.element\r\n     * and specify \"bubbles:true\" to alert any component listeners.\r\n     *\r\n     * @param {string} eventName the event name\r\n     * @param {*} detail event detail data\r\n     */\r\n    dispatchEvent(eventName, detail) {\r\n        this.element.dispatchEvent(new CustomEvent(eventName, {\r\n            bubbles: true,\r\n            detail: detail,\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Render a new Component using a mustache file.\r\n     *\r\n     * It is important to note that this method should NOT be used for loading regular mustache files\r\n     * as it returns a Promise that will only be resolved if the mustache registers a component instance.\r\n     *\r\n     * @param {element} target the DOM element that contains the component\r\n     * @param {string} file the component mustache file to render\r\n     * @param {*} data the mustache data\r\n     * @return {Promise} a promise of the resulting component instance\r\n     */\r\n    renderComponent(target, file, data) {\r\n        return new Promise((resolve, reject) => {\r\n            target.addEventListener('ComponentRegistration:Success', ({detail}) => {\r\n                resolve(detail.component);\r\n            });\r\n            target.addEventListener('ComponentRegistration:Fail', () => {\r\n                reject(`Registration of ${file} fails.`);\r\n            });\r\n            Templates.renderForPromise(\r\n                file,\r\n                data\r\n            ).then(({html, js}) => {\r\n                Templates.replaceNodeContents(target, html, js);\r\n                return true;\r\n            }).catch(error => {\r\n                reject(`Rendering of ${file} throws an error.`);\r\n                throw error;\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Add and bind an event listener to a target and keep track of all event listeners.\r\n     *\r\n     * The native element.addEventListener method is not object oriented friently as the\r\n     * \"this\" represents the element that triggers the event and not the listener class.\r\n     * As components can be unregister and removed at any time, the BaseComponent provides\r\n     * this method to keep track of all component listeners and do all of the bind stuff.\r\n     *\r\n     * @param {Element} target the event target\r\n     * @param {string} type the event name\r\n     * @param {function} listener the class method that recieve the event\r\n     */\r\n    addEventListener(target, type, listener) {\r\n\r\n        // Check if we have the bind version of that listener.\r\n        let bindListener = this.eventHandlers.get(listener);\r\n\r\n        if (bindListener === undefined) {\r\n            bindListener = listener.bind(this);\r\n            this.eventHandlers.set(listener, bindListener);\r\n        }\r\n\r\n        target.addEventListener(type, bindListener);\r\n\r\n        // Keep track of all component event listeners in case we need to remove them.\r\n        this.eventListeners.push({\r\n            target,\r\n            type,\r\n            bindListener,\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Remove an event listener from a component.\r\n     *\r\n     * This method allows components to remove listeners without keeping track of the\r\n     * listeners bind versions of the method. Both addEventListener and removeEventListener\r\n     * keeps internally the relation between the original class method and the bind one.\r\n     *\r\n     * @param {Element} target the event target\r\n     * @param {string} type the event name\r\n     * @param {function} listener the class method that recieve the event\r\n     */\r\n    removeEventListener(target, type, listener) {\r\n        // Check if we have the bind version of that listener.\r\n        let bindListener = this.eventHandlers.get(listener);\r\n\r\n        if (bindListener === undefined) {\r\n            // This listener has not been added.\r\n            return;\r\n        }\r\n\r\n        target.removeEventListener(type, bindListener);\r\n    }\r\n\r\n    /**\r\n     * Remove all event listeners from this component.\r\n     *\r\n     * This method is called also when the component is unregistered or removed.\r\n     *\r\n     * Note that only listeners registered with the addEventListener method\r\n     * will be removed. Other manual listeners will keep active.\r\n     */\r\n    removeAllEventListeners() {\r\n        this.eventListeners.forEach(({target, type, bindListener}) => {\r\n            target.removeEventListener(type, bindListener);\r\n        });\r\n        this.eventListeners = [];\r\n    }\r\n\r\n    /**\r\n     * Remove a previously rendered component instance.\r\n     *\r\n     * This method will remove the component HTML and unregister it from the\r\n     * reactive module.\r\n     */\r\n    remove() {\r\n        this.unregister();\r\n        this.element.remove();\r\n    }\r\n\r\n    /**\r\n     * Unregister the component from the reactive module.\r\n     *\r\n     * This method will disable the component logic, event listeners and watchers\r\n     * but it won't remove any HTML created by the component. However, it will trigger\r\n     * the destroy hook to allow the component to clean parts of the interface.\r\n     */\r\n    unregister() {\r\n        this.reactive.unregisterComponent(this);\r\n        this.removeAllEventListeners();\r\n        this.destroy();\r\n    }\r\n\r\n    /**\r\n     * Dispatch a component registration event to inform the parent node.\r\n     *\r\n     * The registration event is different from the rest of the component events because\r\n     * is the only way in which components can communicate its existence to a possible parent.\r\n     * Most components will be created by including a mustache file, child components\r\n     * must emit a registration event to the parent DOM element to alert about the registration.\r\n     */\r\n    dispatchRegistrationSuccess() {\r\n        // The registration event does not bubble because we just want to comunicate with the parentNode.\r\n        // Otherwise, any component can get multiple registrations events and could not differentiate\r\n        // between child components and grand child components.\r\n        if (this.element.parentNode === undefined) {\r\n            return;\r\n        }\r\n        // This custom element is captured by renderComponent method.\r\n        this.element.parentNode.dispatchEvent(new CustomEvent(\r\n            'ComponentRegistration:Success',\r\n            {\r\n                bubbles: false,\r\n                detail: {component: this},\r\n            }\r\n        ));\r\n    }\r\n\r\n    /**\r\n     * Dispatch a component registration fail event to inform the parent node.\r\n     *\r\n     * As dispatchRegistrationSuccess, this method will communicate the registration fail to the\r\n     * parent node to inform the possible parent component.\r\n     */\r\n    dispatchRegistrationFail() {\r\n        if (this.element.parentNode === undefined) {\r\n            return;\r\n        }\r\n        // This custom element is captured only by renderComponent method.\r\n        this.element.parentNode.dispatchEvent(new CustomEvent(\r\n            'ComponentRegistration:Fail',\r\n            {\r\n                bubbles: false,\r\n                detail: {component: this},\r\n            }\r\n        ));\r\n    }\r\n\r\n    /**\r\n     * Register a child component into the reactive instance.\r\n     *\r\n     * @param {self} component the component to register.\r\n     */\r\n    registerChildComponent(component) {\r\n        component.reactive = this.reactive;\r\n        this.reactive.registerComponent(component);\r\n    }\r\n\r\n    /**\r\n     * Set the lock value and locks or unlocks the element.\r\n     *\r\n     * @param {boolean} locked the new locked value\r\n     */\r\n    set locked(locked) {\r\n        this.setElementLocked(this.element, locked);\r\n    }\r\n\r\n    /**\r\n     * Get the current locked value from the element.\r\n     *\r\n     * @return {boolean}\r\n     */\r\n    get locked() {\r\n        return this.getElementLocked(this.element);\r\n    }\r\n\r\n    /**\r\n     * Lock/unlock an element.\r\n     *\r\n     * @param {Element} target the event target\r\n     * @param {boolean} locked the new locked value\r\n     */\r\n    setElementLocked(target, locked) {\r\n        target.dataset.locked = locked ?? false;\r\n        if (locked) {\r\n            // Disable interactions.\r\n            target.style.pointerEvents = 'none';\r\n            target.style.userSelect = 'none';\r\n            // Check if it is draggable.\r\n            if (target.hasAttribute('draggable')) {\r\n                target.setAttribute('draggable', false);\r\n            }\r\n            target.setAttribute('aria-busy', true);\r\n        } else {\r\n            // Enable interactions.\r\n            target.style.pointerEvents = null;\r\n            target.style.userSelect = null;\r\n            // Check if it was draggable.\r\n            if (target.hasAttribute('draggable')) {\r\n                target.setAttribute('draggable', true);\r\n            }\r\n            target.setAttribute('aria-busy', false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the current locked value from the element.\r\n     *\r\n     * @param {Element} target the event target\r\n     * @return {boolean}\r\n     */\r\n    getElementLocked(target) {\r\n        return target.dataset.locked ?? false;\r\n    }\r\n\r\n    /**\r\n     * Adds an overlay to a specific page element.\r\n     *\r\n     * @param {Object} definition the overlay definition.\r\n     * @param {String} definition.content an optional overlay content.\r\n     * @param {String} definition.classes an optional CSS classes\r\n     * @param {Element} target optional parent object (this.element will be used if none provided)\r\n     */\r\n    async addOverlay(definition, target) {\r\n        if (this._overlay) {\r\n            this.removeOverlay();\r\n        }\r\n        this._overlay = await addOverlay(\r\n            {\r\n                content: definition.content,\r\n                css: definition.classes ?? 'file-drop-zone',\r\n            },\r\n            target ?? this.element\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Remove the current overlay.\r\n     */\r\n    removeOverlay() {\r\n        if (!this._overlay) {\r\n            return;\r\n        }\r\n        removeOverlay(this._overlay);\r\n        this._overlay = null;\r\n    }\r\n\r\n    /**\r\n     * Remove all page overlais.\r\n     */\r\n    removeAllOverlays() {\r\n        removeAllOverlays();\r\n    }\r\n}\r\n"],"names":["constructor","descriptor","undefined","element","HTMLElement","Error","eventHandlers","Map","eventListeners","selectors","events","this","getEvents","create","addSelectors","reactive","dispatchEvent","CustomEvent","bubbles","detail","component","registerComponent","addEventListener","event","_event$detail","stopPropagation","registerChildComponent","destroy","getWatchers","stateReady","getElement","query","dataId","dataSelector","selector","querySelector","getElements","querySelectorAll","newSelectors","selectorName","Object","entries","getSelector","eventName","renderComponent","target","file","data","Promise","resolve","reject","_ref","renderForPromise","then","_ref2","html","js","replaceNodeContents","catch","error","type","listener","bindListener","get","bind","set","push","removeEventListener","removeAllEventListeners","forEach","_ref3","remove","unregister","unregisterComponent","dispatchRegistrationSuccess","parentNode","dispatchRegistrationFail","locked","setElementLocked","getElementLocked","dataset","style","pointerEvents","userSelect","hasAttribute","setAttribute","definition","_overlay","removeOverlay","content","css","classes","removeAllOverlays"],"mappings":"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"}