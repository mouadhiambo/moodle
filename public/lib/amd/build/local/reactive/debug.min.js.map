{"version":3,"file":"debug.min.js","sources":["../../../src/local/reactive/debug.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Reactive module debug tools.\r\n *\r\n * @module     core/local/reactive/debug\r\n * @copyright  2021 Ferran Recio <ferran@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\nimport Reactive from 'core/local/reactive/reactive';\r\nimport log from 'core/log';\r\n\r\n// The list of reactives instances.\r\nconst reactiveInstances = {};\r\n\r\n// The reactive debugging objects.\r\nconst reactiveDebuggers = {};\r\n\r\n/**\r\n * Reactive module debug tools.\r\n *\r\n * If debug is enabled, this reactive module will spy all the reactive instances and keep a record\r\n * of the changes and components they have.\r\n *\r\n * It is important to note that the Debug class is also a Reactive module. The debug instance keeps\r\n * the reactive instances data as its own state. This way it is possible to implement development tools\r\n * that whatches this data.\r\n *\r\n * @class      core/reactive/local/reactive/debug/Debug\r\n * @copyright  2021 Ferran Recio <ferran@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\nclass Debug extends Reactive {\r\n\r\n    /**\r\n     * Set the initial state.\r\n     *\r\n     * @param {object} stateData the initial state data.\r\n     */\r\n    setInitialState(stateData) {\r\n        super.setInitialState(stateData);\r\n        log.debug(`Debug module \"M.reactive\" loaded.`);\r\n    }\r\n\r\n    /**\r\n     * List the currents page reactives instances.\r\n     */\r\n    get list() {\r\n        return JSON.parse(JSON.stringify(this.state.reactives));\r\n    }\r\n\r\n    /**\r\n     * Register a new Reactive instance.\r\n     *\r\n     * This method is called every time a \"new Reactive\" is executed.\r\n     *\r\n     * @param {Reactive} instance the reactive instance\r\n     */\r\n    registerNewInstance(instance) {\r\n\r\n        // Generate a valid variable name for that instance.\r\n        let name = instance.name ?? `instance${this.state.reactives.length}`;\r\n        name = name.replace(/\\W/g, '');\r\n\r\n        log.debug(`Registering new reactive instance \"M.reactive.${name}\"`);\r\n\r\n        reactiveInstances[name] = instance;\r\n        reactiveDebuggers[name] = new DebugInstance(reactiveInstances[name]);\r\n        // Register also in the state.\r\n        this.dispatch('putInstance', name, instance);\r\n        // Add debug watchers to instance.\r\n        const refreshMethod = () => {\r\n            this.dispatch('putInstance', name, instance);\r\n        };\r\n        instance.target.addEventListener('readmode:on', refreshMethod);\r\n        instance.target.addEventListener('readmode:off', refreshMethod);\r\n        instance.target.addEventListener('registerComponent:success', refreshMethod);\r\n        instance.target.addEventListener('transaction:end', refreshMethod);\r\n        // We store the last transaction into the state.\r\n        const storeTransaction = ({detail}) => {\r\n            const changes = detail?.changes;\r\n            this.dispatch('lastTransaction', name, changes);\r\n        };\r\n        instance.target.addEventListener('transaction:end', storeTransaction);\r\n    }\r\n\r\n    /**\r\n     * Returns a debugging object for a specific Reactive instance.\r\n     *\r\n     * A debugging object is a class that wraps a Reactive instance to quick access some of the\r\n     * reactive methods using the browser JS console.\r\n     *\r\n     * @param {string} name the Reactive instance name\r\n     * @returns {DebugInstance} a debug object wrapping the Reactive instance\r\n     */\r\n    debug(name) {\r\n        return reactiveDebuggers[name];\r\n    }\r\n}\r\n\r\n/**\r\n * The debug state mutations class.\r\n *\r\n * @class core/reactive/local/reactive/debug/Mutations\r\n */\r\nclass Mutations {\r\n\r\n    /**\r\n     * Insert or update a new instance into the debug state.\r\n     *\r\n     * @param {StateManager} stateManager the debug state manager\r\n     * @param {string} name the instance name\r\n     * @param {Reactive} instance the reactive instance\r\n     */\r\n    putInstance(stateManager, name, instance) {\r\n        const state = stateManager.state;\r\n\r\n        stateManager.setReadOnly(false);\r\n\r\n        if (state.reactives.has(name)) {\r\n            state.reactives.get(name).countcomponents = instance.components.length;\r\n            state.reactives.get(name).readOnly = instance.stateManager.readonly;\r\n            state.reactives.get(name).modified = new Date().getTime();\r\n        } else {\r\n            state.reactives.add({\r\n                id: name,\r\n                countcomponents: instance.components.length,\r\n                readOnly: instance.stateManager.readonly,\r\n                lastChanges: [],\r\n                modified: new Date().getTime(),\r\n            });\r\n        }\r\n        stateManager.setReadOnly(true);\r\n    }\r\n\r\n    /**\r\n     * Update the lastChanges attribute with a list of changes\r\n     *\r\n     * @param {StateManager} stateManager the debug reactive state\r\n     * @param {string} name the instance name\r\n     * @param {array} changes the list of changes\r\n     */\r\n    lastTransaction(stateManager, name, changes) {\r\n        if (!changes || changes.length === 0) {\r\n            return;\r\n        }\r\n\r\n        const state = stateManager.state;\r\n        const lastChanges = ['transaction:start'];\r\n\r\n        changes.forEach(change => {\r\n            lastChanges.push(change.eventName);\r\n        });\r\n\r\n        lastChanges.push('transaction:end');\r\n\r\n        stateManager.setReadOnly(false);\r\n\r\n        // Dirty hack to force the lastChanges:updated event to be dispatched.\r\n        state.reactives.get(name).lastChanges = [];\r\n\r\n        // Assign the actual value.\r\n        state.reactives.get(name).lastChanges = lastChanges;\r\n\r\n        stateManager.setReadOnly(true);\r\n    }\r\n}\r\n\r\n/**\r\n * Class used to debug a specific instance and manipulate the state from the JS console.\r\n *\r\n * @class      core/reactive/local/reactive/debug/DebugInstance\r\n * @copyright  2021 Ferran Recio <ferran@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\nclass DebugInstance {\r\n\r\n    /**\r\n     * Constructor.\r\n     *\r\n     * @param {Reactive} instance the reactive instance\r\n     */\r\n    constructor(instance) {\r\n        this.instance = instance;\r\n        // Add some debug data directly into the instance. This way we avoid having attributes\r\n        // that will confuse the console aoutocomplete.\r\n        if (instance._reactiveDebugData === undefined) {\r\n            instance._reactiveDebugData = {\r\n                highlighted: false,\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the read only mode.\r\n     *\r\n     * Quick access to the instance setReadOnly method.\r\n     *\r\n     * @param {bool} value the new read only value\r\n     */\r\n    set readOnly(value) {\r\n        this.instance.stateManager.setReadOnly(value);\r\n    }\r\n\r\n    /**\r\n     * Get the read only value\r\n     *\r\n     * @returns {bool}\r\n     */\r\n    get readOnly() {\r\n        return this.instance.stateManager.readonly;\r\n    }\r\n\r\n    /**\r\n     * Return the current state object.\r\n     *\r\n     * @returns {object}\r\n     */\r\n    get state() {\r\n        return this.instance.state;\r\n    }\r\n\r\n    /**\r\n     * Tooggle the reactive HTML element highlight registered in this reactive instance.\r\n     *\r\n     * @param {bool} value the highlight value\r\n     */\r\n    set highlight(value) {\r\n        this.instance._reactiveDebugData.highlighted = value;\r\n        this.instance.components.forEach(({element}) => {\r\n            const border = (value) ? `thick solid #0000FF` : '';\r\n            element.style.border = border;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the current highligh value.\r\n     *\r\n     * @returns {bool}\r\n     */\r\n    get highlight() {\r\n        return this.instance._reactiveDebugData.highlighted;\r\n    }\r\n\r\n    /**\r\n     * List all the components registered in this instance.\r\n     *\r\n     * @returns {array}\r\n     */\r\n    get components() {\r\n        return [...this.instance.components];\r\n    }\r\n\r\n    /**\r\n     * List all the state changes evenet pending to dispatch.\r\n     *\r\n     * @returns {array}\r\n     */\r\n    get changes() {\r\n        const result = [];\r\n        this.instance.stateManager.eventsToPublish.forEach(\r\n            (element) => {\r\n                result.push(element.eventName);\r\n            }\r\n        );\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Dispatch a change in the state.\r\n     *\r\n     * Usually reactive modules throw an error directly to the components when something\r\n     * goes wrong. However, course editor can directly display a notification.\r\n     *\r\n     * @method dispatch\r\n     * @param {*} args\r\n     */\r\n    async dispatch(...args) {\r\n        this.instance.dispatch(...args);\r\n    }\r\n\r\n    /**\r\n     * Return all the HTML elements registered in the instance components.\r\n     *\r\n     * @returns {array}\r\n     */\r\n    get elements() {\r\n        const result = [];\r\n        this.instance.components.forEach(({element}) => {\r\n            result.push(element);\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Return a plain copy of the state data.\r\n     *\r\n     * @returns {object}\r\n     */\r\n    get stateData() {\r\n        return JSON.parse(JSON.stringify(this.state));\r\n    }\r\n\r\n    /**\r\n     * Process an update state array.\r\n     *\r\n     * @param {array} updates an array of update state messages\r\n     */\r\n    processUpdates(updates) {\r\n        this.instance.stateManager.processUpdates(updates);\r\n    }\r\n}\r\n\r\nconst stateChangedEventName = 'core_reactive_debug:stateChanged';\r\n\r\n/**\r\n * Internal state changed event.\r\n *\r\n * @method dispatchStateChangedEvent\r\n * @param {object} detail the full state\r\n * @param {object} target the custom event target (document if none provided)\r\n */\r\nfunction dispatchStateChangedEvent(detail, target) {\r\n    if (target === undefined) {\r\n        target = document;\r\n    }\r\n    target.dispatchEvent(\r\n        new CustomEvent(\r\n            stateChangedEventName,\r\n            {\r\n                bubbles: true,\r\n                detail: detail,\r\n            }\r\n        )\r\n    );\r\n}\r\n\r\n/**\r\n * The main init method to initialize the reactive debug.\r\n * @returns {object}\r\n */\r\nexport const initDebug = () => {\r\n    const debug = new Debug({\r\n        name: 'CoreReactiveDebug',\r\n        eventName: stateChangedEventName,\r\n        eventDispatch: dispatchStateChangedEvent,\r\n        mutations: new Mutations(),\r\n        state: {\r\n            reactives: [],\r\n        },\r\n    });\r\n\r\n    // The reactiveDebuggers will be used as a way of access the debug instances but also to register every new\r\n    // instance. To ensure this will update the reactive debug state we add the registerNewInstance method to it.\r\n    reactiveDebuggers.registerNewInstance = debug.registerNewInstance.bind(debug);\r\n\r\n    return {\r\n        debug,\r\n        debuggers: reactiveDebuggers,\r\n    };\r\n};\r\n"],"names":["reactiveInstances","reactiveDebuggers","Debug","Reactive","setInitialState","stateData","debug","list","JSON","parse","stringify","this","state","reactives","registerNewInstance","instance","name","length","replace","DebugInstance","dispatch","refreshMethod","target","addEventListener","_ref","detail","changes","Mutations","putInstance","stateManager","setReadOnly","has","get","countcomponents","components","readOnly","readonly","modified","Date","getTime","add","id","lastChanges","lastTransaction","forEach","change","push","eventName","constructor","undefined","_reactiveDebugData","highlighted","value","highlight","_ref2","element","border","style","result","eventsToPublish","elements","_ref3","processUpdates","updates","dispatchStateChangedEvent","document","dispatchEvent","CustomEvent","bubbles","eventDispatch","mutations","bind","debuggers"],"mappings":"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"}