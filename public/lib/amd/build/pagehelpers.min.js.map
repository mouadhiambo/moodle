{"version":3,"file":"pagehelpers.min.js","sources":["../src/pagehelpers.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Page utility helpers.\r\n *\r\n * @module core/pagehelpers\r\n * @copyright  2023 Ferran Recio <ferran@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\n/**\r\n * Maximum sizes for breakpoints. This needs to correspond with Bootstrap\r\n * Breakpoints\r\n *\r\n * @private\r\n */\r\nconst Sizes = {\r\n    small: 576,\r\n    medium: 991,\r\n    large: 1400\r\n};\r\n\r\nconst Selectors = {\r\n    focusable: 'a, button, input, select, textarea, [tabindex]:not([tabindex=\"-1\"])',\r\n};\r\n\r\nconst Classes = {\r\n    behatSite: 'behat-site',\r\n};\r\n\r\n/**\r\n * Check fi the current page is a Behat site.\r\n * @returns {boolean} true if the current page is a Behat site.\r\n */\r\nexport const isBehatSite = () => {\r\n    return document.body.classList.contains(Classes.behatSite);\r\n};\r\n\r\n/**\r\n * Get the current body width.\r\n * @returns {number} the current body width.\r\n */\r\nexport const getCurrentWidth = () => {\r\n    const DomRect = document.body.getBoundingClientRect();\r\n    return DomRect.x + DomRect.width;\r\n};\r\n\r\n/**\r\n * Check if the user uses an extra small size browser.\r\n *\r\n * @returns {boolean} true if the body is smaller than sizes.small max size.\r\n */\r\nexport const isExtraSmall = () => {\r\n    const browserWidth = getCurrentWidth();\r\n    return browserWidth < Sizes.small;\r\n};\r\n\r\n/**\r\n * Check if the user uses a small size browser.\r\n *\r\n * @returns {boolean} true if the body is smaller than sizes.medium max size.\r\n */\r\nexport const isSmall = () => {\r\n    const browserWidth = getCurrentWidth();\r\n    return browserWidth < Sizes.medium;\r\n};\r\n\r\n/**\r\n * Check if the user uses a large size browser.\r\n *\r\n * @returns {boolean} true if the body is smaller than sizes.large max size.\r\n */\r\nexport const isLarge = () => {\r\n    const browserWidth = getCurrentWidth();\r\n    return browserWidth >= Sizes.large;\r\n};\r\n\r\n/**\r\n * Get the first focusable element inside a container.\r\n * @param {HTMLElement} [container] Container to search in. Defaults to document.\r\n * @returns {HTMLElement|null}\r\n */\r\nexport const firstFocusableElement = (container) => {\r\n    const containerElement = container || document;\r\n    return containerElement.querySelector(Selectors.focusable);\r\n};\r\n\r\n/**\r\n * Get the last focusable element inside a container.\r\n * @param {HTMLElement} [container] Container to search in. Defaults to document.\r\n * @returns {HTMLElement|null}\r\n */\r\nexport const lastFocusableElement = (container) => {\r\n    const containerElement = container || document;\r\n    const focusableElements = containerElement.querySelectorAll(Selectors.focusable);\r\n    return focusableElements[focusableElements.length - 1] ?? null;\r\n};\r\n\r\n/**\r\n * Get all focusable elements inside a container.\r\n * @param {HTMLElement} [container] Container to search in. Defaults to document.\r\n * @returns {HTMLElement[]}\r\n */\r\nexport const focusableElements = (container) => {\r\n    const containerElement = container || document;\r\n    return containerElement.querySelectorAll(Selectors.focusable);\r\n};\r\n\r\n/**\r\n * Get the previous focusable element in a container.\r\n * It uses the current focused element to know where to start the search.\r\n * @param {HTMLElement} [container] Container to search in. Defaults to document.\r\n * @param {Boolean} [loopSelection] Whether to loop selection or not. Default to false.\r\n * @returns {HTMLElement|null}\r\n */\r\nexport const previousFocusableElement = (container, loopSelection) => {\r\n    return getRelativeFocusableElement(container, loopSelection, -1);\r\n};\r\n\r\n/**\r\n * Get the next focusable element in a container.\r\n * It uses the current focused element to know where to start the search.\r\n * @param {HTMLElement} [container] Container to search in. Defaults to document.\r\n * @param {Boolean} [loopSelection] Whether to loop selection or not. Default to false.\r\n * @returns {HTMLElement|null}\r\n */\r\nexport const nextFocusableElement = (container, loopSelection) => {\r\n    return getRelativeFocusableElement(container, loopSelection, 1);\r\n};\r\n\r\n/**\r\n * Internal function to get the next or previous focusable element.\r\n * @param {HTMLElement} [container] Container to search in. Defaults to document.\r\n * @param {Boolean} [loopSelection] Whether to loop selection or not.\r\n * @param {Number} [direction] Direction to search in. 1 for next, -1 for previous.\r\n * @returns {HTMLElement|null}\r\n * @private\r\n */\r\nconst getRelativeFocusableElement = (container, loopSelection, direction) => {\r\n    const focusedElement = document.activeElement;\r\n    const focusables = [...focusableElements(container)];\r\n    const focusedIndex = focusables.indexOf(focusedElement);\r\n\r\n    if (focusedIndex === -1) {\r\n        return null;\r\n    }\r\n\r\n    const newIndex = focusedIndex + direction;\r\n\r\n    if (focusables[newIndex] !== undefined) {\r\n        return focusables[newIndex];\r\n    }\r\n    if (loopSelection != true) {\r\n        return null;\r\n    }\r\n    if (direction > 0) {\r\n        return focusables[0] ?? null;\r\n    }\r\n    return focusables[focusables.length - 1] ?? null;\r\n};\r\n"],"names":["Sizes","Selectors","Classes","document","body","classList","contains","getCurrentWidth","DomRect","getBoundingClientRect","x","width","container","querySelector","focusableElements","querySelectorAll","length","loopSelection","getRelativeFocusableElement","direction","focusedElement","activeElement","focusables","focusedIndex","indexOf","newIndex","undefined"],"mappings":";;;;;;;;MA6BMA,YACK,IADLA,aAEM,IAFNA,YAGK,KAGLC,oBACS,sEAGTC,kBACS,kCAOY,IAChBC,SAASC,KAAKC,UAAUC,SAASJ,yBAO/BK,gBAAkB,WACrBC,QAAUL,SAASC,KAAKK,+BACvBD,QAAQE,EAAIF,QAAQG,sEAQH,IACHJ,kBACCP,6BAQH,IACEO,kBACCP,8BAQH,IACEO,mBACEP,2CAQWY,YACTA,WAAaT,UACdU,cAAcZ,mDAQLW,yCAE3BE,mBADmBF,WAAaT,UACKY,iBAAiBd,uDACrDa,kBAAkBA,kBAAkBE,OAAS,oDAAM,YAQjDF,kBAAqBF,YACLA,WAAaT,UACdY,iBAAiBd,oGAUL,CAACW,UAAWK,gBACzCC,4BAA4BN,UAAWK,eAAgB,iCAU9B,CAACL,UAAWK,gBACrCC,4BAA4BN,UAAWK,cAAe,SAW3DC,4BAA8B,CAACN,UAAWK,cAAeE,mCACrDC,eAAiBjB,SAASkB,cAC1BC,WAAa,IAAIR,kBAAkBF,YACnCW,aAAeD,WAAWE,QAAQJ,oBAElB,IAAlBG,oBACO,WAGLE,SAAWF,aAAeJ,sBAEHO,IAAzBJ,WAAWG,UACJH,WAAWG,UAED,GAAjBR,cACO,KAEPE,UAAY,uBACLG,WAAW,wCAAM,yBAErBA,WAAWA,WAAWN,OAAS,sCAAM"}