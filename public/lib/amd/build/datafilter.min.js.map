{"version":3,"file":"datafilter.min.js","sources":["../src/datafilter.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Data filter management.\r\n *\r\n * @module     core/datafilter\r\n * @copyright  2020 Andrew Nicols <andrew@nicols.co.uk>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\nimport CourseFilter from 'core/datafilter/filtertypes/courseid';\r\nimport GenericFilter from 'core/datafilter/filtertype';\r\nimport {getStrings} from 'core/str';\r\nimport Notification from 'core/notification';\r\nimport Pending from 'core/pending';\r\nimport Selectors from 'core/datafilter/selectors';\r\nimport Templates from 'core/templates';\r\nimport CustomEvents from 'core/custom_interaction_events';\r\nimport jQuery from 'jquery';\r\n\r\nexport default class {\r\n\r\n    /**\r\n     * Initialise the filter on the element with the given filterSet and callback.\r\n     *\r\n     * @param {HTMLElement} filterSet The filter element.\r\n     * @param {Function} applyCallback Callback function when updateTableFromFilter\r\n     */\r\n    constructor(filterSet, applyCallback) {\r\n\r\n        this.filterSet = filterSet;\r\n        this.applyCallback = applyCallback;\r\n        // Keep a reference to all of the active filters.\r\n        this.activeFilters = {\r\n            courseid: new CourseFilter('courseid', filterSet),\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Initialise event listeners to the filter.\r\n     */\r\n    init() {\r\n        // Add listeners for the main actions.\r\n        this.filterSet.querySelector(Selectors.filterset.region).addEventListener('click', e => {\r\n            if (e.target.closest(Selectors.filterset.actions.addRow)) {\r\n                e.preventDefault();\r\n\r\n                this.addFilterRow();\r\n            }\r\n\r\n            if (e.target.closest(Selectors.filterset.actions.applyFilters)) {\r\n                e.preventDefault();\r\n                this.updateTableFromFilter();\r\n            }\r\n\r\n            if (e.target.closest(Selectors.filterset.actions.resetFilters)) {\r\n                e.preventDefault();\r\n\r\n                this.removeAllFilters();\r\n            }\r\n        });\r\n\r\n        // Add the listener to remove a single filter.\r\n        this.filterSet.querySelector(Selectors.filterset.regions.filterlist).addEventListener('click', e => {\r\n            if (e.target.closest(Selectors.filter.actions.remove)) {\r\n                e.preventDefault();\r\n\r\n                this.removeOrReplaceFilterRow(e.target.closest(Selectors.filter.region), true);\r\n            }\r\n        });\r\n\r\n        // Add listeners for the filter type selection.\r\n        let filterRegion = jQuery(this.getFilterRegion());\r\n        CustomEvents.define(filterRegion, [CustomEvents.events.accessibleChange]);\r\n        filterRegion.on(CustomEvents.events.accessibleChange, e => {\r\n            const typeField = e.target.closest(Selectors.filter.fields.type);\r\n            if (typeField && typeField.value) {\r\n                const filter = e.target.closest(Selectors.filter.region);\r\n\r\n                this.addFilter(filter, typeField.value);\r\n            }\r\n        });\r\n\r\n        this.filterSet.querySelector(Selectors.filterset.fields.join).addEventListener('change', e => {\r\n            this.filterSet.dataset.filterverb = e.target.value;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the filter list region.\r\n     *\r\n     * @return {HTMLElement}\r\n     */\r\n    getFilterRegion() {\r\n        return this.filterSet.querySelector(Selectors.filterset.regions.filterlist);\r\n    }\r\n\r\n    /**\r\n     * Add a filter row.\r\n     *\r\n     * @param {Object} filterdata Optional, data for adding for row with an existing filter.\r\n     * @return {Promise}\r\n     */\r\n    addFilterRow(filterdata = {}) {\r\n        const pendingPromise = new Pending('core/datafilter:addFilterRow');\r\n        const rownum = filterdata.rownum ?? 1 + this.getFilterRegion().querySelectorAll(Selectors.filter.region).length;\r\n        return Templates.renderForPromise('core/datafilter/filter_row', {\"rownumber\": rownum})\r\n            .then(({html, js}) => {\r\n                const newContentNodes = Templates.appendNodeContents(this.getFilterRegion(), html, js);\r\n\r\n                return newContentNodes;\r\n            })\r\n            .then(filterRow => {\r\n                // Note: This is a nasty hack.\r\n                // We should try to find a better way of doing this.\r\n                // We do not have the list of types in a readily consumable format, so we take the pre-rendered one and copy\r\n                // it in place.\r\n                const typeList = this.filterSet.querySelector(Selectors.data.typeList);\r\n\r\n                filterRow.forEach(contentNode => {\r\n                    const contentTypeList = contentNode.querySelector(Selectors.filter.fields.type);\r\n\r\n                    if (contentTypeList) {\r\n                        contentTypeList.innerHTML = typeList.innerHTML;\r\n                    }\r\n                });\r\n\r\n                return filterRow;\r\n            })\r\n            .then(filterRow => {\r\n                this.updateFiltersOptions();\r\n\r\n                return filterRow;\r\n            })\r\n            .then(result => {\r\n                pendingPromise.resolve();\r\n\r\n                // If an existing filter is passed in, add it. Otherwise, leave the row empty.\r\n                if (filterdata.filtertype) {\r\n                    result.forEach(filter => {\r\n                        this.addFilter(filter, filterdata.filtertype, filterdata.values,\r\n                            filterdata.jointype, filterdata.filteroptions);\r\n                    });\r\n                }\r\n                return result;\r\n            })\r\n            .catch(Notification.exception);\r\n    }\r\n\r\n    /**\r\n     * Get the filter data source node fro the specified filter type.\r\n     *\r\n     * @param {String} filterType\r\n     * @return {HTMLElement}\r\n     */\r\n    getFilterDataSource(filterType) {\r\n        const filterDataNode = this.filterSet.querySelector(Selectors.filterset.regions.datasource);\r\n\r\n        return filterDataNode.querySelector(Selectors.data.fields.byName(filterType));\r\n    }\r\n\r\n    /**\r\n     * Add a filter to the list of active filters, performing any necessary setup.\r\n     *\r\n     * @param {HTMLElement} filterRow\r\n     * @param {String} filterType\r\n     * @param {Array} initialFilterValues The initially selected values for the filter\r\n     * @param {String} filterJoin\r\n     * @param {Object} filterOptions\r\n     * @returns {Filter}\r\n     */\r\n    async addFilter(filterRow, filterType, initialFilterValues, filterJoin, filterOptions) {\r\n        // Name the filter on the filter row.\r\n        filterRow.dataset.filterType = filterType;\r\n\r\n        const filterDataNode = this.getFilterDataSource(filterType);\r\n\r\n        // Instantiate the Filter class.\r\n        let Filter = GenericFilter;\r\n        if (filterDataNode.dataset.filterTypeClass) {\r\n\r\n            // Ensure the filter class passed through exists, otherwise the filtering will break.\r\n            try {\r\n                Filter = await import(filterDataNode.dataset.filterTypeClass);\r\n            } catch (error) {\r\n                Notification.exception(error);\r\n            }\r\n\r\n        }\r\n        this.activeFilters[filterType] = new Filter(filterType, this.filterSet, initialFilterValues, filterOptions);\r\n\r\n        // Disable the select.\r\n        const typeField = filterRow.querySelector(Selectors.filter.fields.type);\r\n        typeField.value = filterType;\r\n        typeField.disabled = 'disabled';\r\n        // Update the join list.\r\n        this.updateJoinList(JSON.parse(filterDataNode.dataset.joinList), filterRow);\r\n        const joinField = filterRow.querySelector(Selectors.filter.fields.join);\r\n        if (!isNaN(filterJoin)) {\r\n            joinField.value = filterJoin;\r\n        }\r\n        // Update the list of available filter types.\r\n        this.updateFiltersOptions();\r\n\r\n        return this.activeFilters[filterType];\r\n    }\r\n\r\n    /**\r\n     * Get the registered filter class for the named filter.\r\n     *\r\n     * @param {String} name\r\n     * @return {Object} See the Filter class.\r\n     */\r\n    getFilterObject(name) {\r\n        return this.activeFilters[name];\r\n    }\r\n\r\n    /**\r\n     * Remove or replace the specified filter row and associated class, ensuring that if there is only one filter row,\r\n     * that it is replaced instead of being removed.\r\n     *\r\n     * @param {HTMLElement} filterRow\r\n     * @param {Bool} refreshContent Whether to refresh the table content when removing\r\n     */\r\n    removeOrReplaceFilterRow(filterRow, refreshContent) {\r\n        const filterCount = this.getFilterRegion().querySelectorAll(Selectors.filter.region).length;\r\n        if (filterCount === 1) {\r\n            this.replaceFilterRow(filterRow, refreshContent);\r\n        } else {\r\n            this.removeFilterRow(filterRow, refreshContent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove the specified filter row and associated class.\r\n     *\r\n     * @param {HTMLElement} filterRow\r\n     * @param {Bool} refreshContent Whether to refresh the table content when removing\r\n     */\r\n    async removeFilterRow(filterRow, refreshContent = true) {\r\n        if (filterRow.querySelector(Selectors.data.required)) {\r\n            return;\r\n        }\r\n        const filterType = filterRow.querySelector(Selectors.filter.fields.type);\r\n        const hasFilterValue = !!filterType.value;\r\n\r\n        // Remove the filter object.\r\n        this.removeFilterObject(filterRow.dataset.filterType);\r\n\r\n        // Remove the actual filter HTML.\r\n        filterRow.remove();\r\n\r\n        // Update the list of available filter types.\r\n        this.updateFiltersOptions();\r\n\r\n        if (hasFilterValue && refreshContent) {\r\n            // Refresh the table if there was any content in this row.\r\n            this.updateTableFromFilter();\r\n        }\r\n\r\n        // Update filter fieldset legends.\r\n        const filterLegends = await this.getAvailableFilterLegends();\r\n\r\n        this.getFilterRegion().querySelectorAll(Selectors.filter.region).forEach((filterRow, index) => {\r\n            filterRow.querySelector('legend').innerText = filterLegends[index];\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Replace the specified filter row with a new one.\r\n     *\r\n     * @param {HTMLElement} filterRow\r\n     * @param {Bool} refreshContent Whether to refresh the table content when removing\r\n     * @param {Number} rowNum The number used to label the filter fieldset legend (eg Row 1). Defaults to 1 (the first filter).\r\n     * @return {Promise}\r\n     */\r\n    replaceFilterRow(filterRow, refreshContent = true, rowNum = 1) {\r\n        if (filterRow.querySelector(Selectors.data.required)) {\r\n            return;\r\n        }\r\n        // Remove the filter object.\r\n        this.removeFilterObject(filterRow.dataset.filterType);\r\n\r\n        return Templates.renderForPromise('core/datafilter/filter_row', {\"rownumber\": rowNum})\r\n            .then(({html, js}) => {\r\n                const newContentNodes = Templates.replaceNode(filterRow, html, js);\r\n\r\n                return newContentNodes;\r\n            })\r\n            .then(filterRow => {\r\n                // Note: This is a nasty hack.\r\n                // We should try to find a better way of doing this.\r\n                // We do not have the list of types in a readily consumable format, so we take the pre-rendered one and copy\r\n                // it in place.\r\n                const typeList = this.filterSet.querySelector(Selectors.data.typeList);\r\n\r\n                filterRow.forEach(contentNode => {\r\n                    const contentTypeList = contentNode.querySelector(Selectors.filter.fields.type);\r\n\r\n                    if (contentTypeList) {\r\n                        contentTypeList.innerHTML = typeList.innerHTML;\r\n                    }\r\n                });\r\n\r\n                return filterRow;\r\n            })\r\n            .then(filterRow => {\r\n                this.updateFiltersOptions();\r\n\r\n                return filterRow;\r\n            })\r\n            .then(filterRow => {\r\n                // Refresh the table.\r\n                if (refreshContent) {\r\n                    return this.updateTableFromFilter();\r\n                } else {\r\n                    return filterRow;\r\n                }\r\n            })\r\n            .catch(Notification.exception);\r\n    }\r\n\r\n    /**\r\n     * Remove the Filter Object from the register.\r\n     *\r\n     * @param {string} filterName The name of the filter to be removed\r\n     */\r\n    removeFilterObject(filterName) {\r\n        if (filterName) {\r\n            const filter = this.getFilterObject(filterName);\r\n            if (filter) {\r\n                filter.tearDown();\r\n\r\n                // Remove from the list of active filters.\r\n                delete this.activeFilters[filterName];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all filters.\r\n     *\r\n     * @returns {Promise}\r\n     */\r\n    removeAllFilters() {\r\n        const filters = this.getFilterRegion().querySelectorAll(Selectors.filter.region);\r\n        filters.forEach(filterRow => this.removeOrReplaceFilterRow(filterRow, false));\r\n\r\n        // Refresh the table.\r\n        return this.updateTableFromFilter();\r\n    }\r\n\r\n    /**\r\n     * Remove any empty filters.\r\n     */\r\n    removeEmptyFilters() {\r\n        const filters = this.getFilterRegion().querySelectorAll(Selectors.filter.region);\r\n        filters.forEach(filterRow => {\r\n            const filterType = filterRow.querySelector(Selectors.filter.fields.type);\r\n            if (!filterType.value) {\r\n                this.removeOrReplaceFilterRow(filterRow, false);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Update the list of filter types to filter out those already selected.\r\n     */\r\n    updateFiltersOptions() {\r\n        const filters = this.getFilterRegion().querySelectorAll(Selectors.filter.region);\r\n        filters.forEach(filterRow => {\r\n            const options = filterRow.querySelectorAll(Selectors.filter.fields.type + ' option');\r\n            options.forEach(option => {\r\n                if (option.value === filterRow.dataset.filterType) {\r\n                    option.classList.remove('hidden');\r\n                    option.disabled = false;\r\n                } else if (this.activeFilters[option.value]) {\r\n                    option.classList.add('hidden');\r\n                    option.disabled = true;\r\n                } else {\r\n                    option.classList.remove('hidden');\r\n                    option.disabled = false;\r\n                }\r\n            });\r\n        });\r\n\r\n        // Configure the state of the \"Add row\" button.\r\n        // This button is disabled when there is a filter row available for each condition.\r\n        const addRowButton = this.filterSet.querySelector(Selectors.filterset.actions.addRow);\r\n        const filterDataNode = this.filterSet.querySelectorAll(Selectors.data.fields.all);\r\n        if (filterDataNode.length <= filters.length) {\r\n            addRowButton.setAttribute('disabled', 'disabled');\r\n        } else {\r\n            addRowButton.removeAttribute('disabled');\r\n        }\r\n\r\n        if (filters.length === 1) {\r\n            this.filterSet.querySelector(Selectors.filterset.regions.filtermatch).classList.add('hidden');\r\n            this.filterSet.querySelector(Selectors.filterset.fields.join).value = 2;\r\n            this.filterSet.dataset.filterverb = 2;\r\n        } else {\r\n            this.filterSet.querySelector(Selectors.filterset.regions.filtermatch).classList.remove('hidden');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the Dynamic table based upon the current filter.\r\n     *\r\n     * @param {bool} validate Should we validate the filters? We might want to skip this if the filters won't have changed,\r\n     *     for example for pagination/sorting.\r\n     */\r\n    updateTableFromFilter(validate = true) {\r\n        const pendingPromise = new Pending('core/datafilter:updateTableFromFilter');\r\n\r\n        const filters = {};\r\n        let valid = true;\r\n        Object.values(this.activeFilters).forEach(filter => {\r\n            if (validate) {\r\n                valid = valid && filter.validate();\r\n            }\r\n            filters[filter.filterValue.name] = filter.filterValue;\r\n        });\r\n        if (validate) {\r\n            valid = valid && document.querySelector(Selectors.filter.region).closest('form').reportValidity();\r\n        }\r\n        if (this.applyCallback && valid) {\r\n            this.applyCallback(filters, pendingPromise);\r\n        } else {\r\n            pendingPromise.resolve();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fetch the strings used to populate the fieldset legends for the maximum number of filters possible.\r\n     *\r\n     * @return {array}\r\n     */\r\n    async getAvailableFilterLegends() {\r\n        const maxFilters = document.querySelector(Selectors.data.typeListSelect).length - 1;\r\n        let requests = [];\r\n\r\n        [...Array(maxFilters)].forEach((_, rowIndex) => {\r\n            requests.push({\r\n                \"key\": \"filterrowlegend\",\r\n                \"component\": \"core\",\r\n                // Add 1 since rows begin at 1 (index begins at zero).\r\n                \"param\": rowIndex + 1\r\n            });\r\n        });\r\n\r\n        const legendStrings = await getStrings(requests)\r\n            .then(fetchedStrings => {\r\n                return fetchedStrings;\r\n            })\r\n            .catch(Notification.exception);\r\n\r\n        return legendStrings;\r\n    }\r\n\r\n    /**\r\n     * Update the list of join types for a filter.\r\n     *\r\n     * This will update the list of join types based on the allowed types defined for a filter.\r\n     * If only one type is allowed, the list will be hidden.\r\n     *\r\n     * @param {Array} filterJoinList Array of join types, a subset of the regularJoinList array in this function.\r\n     * @param {Element} filterRow The row being updated.\r\n     */\r\n    updateJoinList(filterJoinList, filterRow) {\r\n        const regularJoinList = [0, 1, 2];\r\n        // If a join list was specified for this filter, find the default join list and disable the options that are not allowed\r\n        // for this filter.\r\n        if (filterJoinList.length !== 0) {\r\n            const joinField = filterRow.querySelector(Selectors.filter.fields.join);\r\n            // Check each option from the default list, and disable the option in this filter row if it is not allowed\r\n            // for this filter.\r\n            regularJoinList.forEach((join) => {\r\n                if (!filterJoinList.includes(join)) {\r\n                    joinField.options[join].classList.add('hidden');\r\n                    joinField.options[join].disabled = true;\r\n                }\r\n            });\r\n            // Now remove the disabled options, and hide the select list of there is only one option left.\r\n            joinField.options.forEach((element, index) => {\r\n                if (element.disabled) {\r\n                    joinField.options[index] = null;\r\n                }\r\n            });\r\n            if (joinField.options.length === 1) {\r\n                joinField.hidden = true;\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"names":["constructor","filterSet","applyCallback","activeFilters","courseid","CourseFilter","init","querySelector","Selectors","filterset","region","addEventListener","e","target","closest","actions","addRow","preventDefault","addFilterRow","applyFilters","updateTableFromFilter","resetFilters","removeAllFilters","regions","filterlist","filter","remove","removeOrReplaceFilterRow","filterRegion","this","getFilterRegion","define","CustomEvents","events","accessibleChange","on","typeField","fields","type","value","addFilter","join","dataset","filterverb","filterdata","pendingPromise","Pending","rownum","querySelectorAll","length","Templates","renderForPromise","then","_ref","html","js","appendNodeContents","filterRow","typeList","data","forEach","contentNode","contentTypeList","innerHTML","updateFiltersOptions","result","resolve","filtertype","values","jointype","filteroptions","catch","Notification","exception","getFilterDataSource","filterType","datasource","byName","initialFilterValues","filterJoin","filterOptions","filterDataNode","Filter","GenericFilter","filterTypeClass","error","disabled","updateJoinList","JSON","parse","joinList","joinField","isNaN","getFilterObject","name","refreshContent","replaceFilterRow","removeFilterRow","required","hasFilterValue","removeFilterObject","filterLegends","getAvailableFilterLegends","index","innerText","rowNum","_ref2","replaceNode","filterName","tearDown","removeEmptyFilters","filters","option","classList","add","addRowButton","all","setAttribute","removeAttribute","filtermatch","validate","valid","Object","filterValue","document","reportValidity","maxFilters","typeListSelect","requests","Array","_","rowIndex","push","fetchedStrings","filterJoinList","regularJoinList","includes","options","element","hidden"],"mappings":"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"}