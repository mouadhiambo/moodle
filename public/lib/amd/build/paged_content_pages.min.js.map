{"version":3,"file":"paged_content_pages.min.js","sources":["../src/paged_content_pages.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Javascript for showing/hiding pages of content.\r\n *\r\n * @module     core/paged_content_pages\r\n * @copyright  2018 Ryan Wyllie <ryan@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\ndefine(\r\n    [\r\n        'jquery',\r\n        'core/templates',\r\n        'core/notification',\r\n        'core/pubsub',\r\n        'core/paged_content_events',\r\n        'core/pending',\r\n    ],\r\n    function(\r\n        $,\r\n        Templates,\r\n        Notification,\r\n        PubSub,\r\n        PagedContentEvents,\r\n        Pending\r\n    ) {\r\n\r\n    var SELECTORS = {\r\n        ROOT: '[data-region=\"page-container\"]',\r\n        PAGE_REGION: '[data-region=\"paged-content-page\"]',\r\n        ACTIVE_PAGE_REGION: '[data-region=\"paged-content-page\"].active'\r\n    };\r\n\r\n    var TEMPLATES = {\r\n        PAGING_CONTENT_ITEM: 'core/paged_content_page',\r\n        LOADING: 'core/overlay_loading'\r\n    };\r\n\r\n    var PRELOADING_GRACE_PERIOD = 300;\r\n\r\n    /**\r\n     * Find a page by the number.\r\n     *\r\n     * @param {object} root The root element.\r\n     * @param {Number} pageNumber The number of the page to be found.\r\n     * @returns {jQuery} The page.\r\n     */\r\n    var findPage = function(root, pageNumber) {\r\n        return root.find('[data-page=\"' + pageNumber + '\"]');\r\n    };\r\n\r\n    /**\r\n     * Show the loading spinner until the returned deferred is resolved by the\r\n     * calling code.\r\n     *\r\n     * The loading spinner is only rendered after a short grace period to avoid\r\n     * having it flash up briefly in the interface.\r\n     *\r\n     * @param {object} root The root element.\r\n     * @returns {promise} The page.\r\n     */\r\n    var startLoading = function(root) {\r\n        var deferred = $.Deferred();\r\n        root.attr('aria-busy', true);\r\n\r\n        var pendingPromise = new Pending('core/paged_content_pages:startLoading');\r\n\r\n        Templates.render(TEMPLATES.LOADING, {visible: true})\r\n            .then(function(html) {\r\n                var loadingSpinner = $(html);\r\n                // Put this in a timer to give the calling code 300 milliseconds\r\n                // to render the content before we show the loading spinner. This\r\n                // helps prevent a loading icon flicker on close to instant\r\n                // rendering.\r\n                var timerId = setTimeout(function() {\r\n                    root.css('position', 'relative');\r\n                    loadingSpinner.appendTo(root);\r\n                }, PRELOADING_GRACE_PERIOD);\r\n\r\n                deferred.always(function() {\r\n                    clearTimeout(timerId);\r\n                    // Remove the loading spinner when our deferred is resolved\r\n                    // by the calling code.\r\n                    loadingSpinner.remove();\r\n                    root.css('position', '');\r\n                    root.removeAttr('aria-busy');\r\n\r\n                    pendingPromise.resolve();\r\n                    return;\r\n                });\r\n\r\n                return;\r\n            })\r\n            .fail(Notification.exception);\r\n\r\n        return deferred;\r\n    };\r\n\r\n    /**\r\n     * Render the result of the page promise in a paged content page.\r\n     *\r\n     * This function returns a promise that is resolved with the new paged content\r\n     * page.\r\n     *\r\n     * @param {object} root The root element.\r\n     * @param {promise} pagePromise The promise resolved with HTML and JS to render in the page.\r\n     * @param {Number} pageNumber The page number.\r\n     * @returns {promise} The page.\r\n     */\r\n    var renderPagePromise = function(root, pagePromise, pageNumber) {\r\n        var deferred = $.Deferred();\r\n        pagePromise.then(function(html, pageJS) {\r\n            pageJS = pageJS || '';\r\n            // When we get the contents to be rendered we can pass it in as the\r\n            // content for a new page.\r\n            Templates.render(TEMPLATES.PAGING_CONTENT_ITEM, {\r\n                page: pageNumber,\r\n                content: html\r\n            })\r\n            .then(function(html) {\r\n                // Make sure the JS we got from the page promise is being added\r\n                // to the page when we render the page.\r\n                Templates.appendNodeContents(root, html, pageJS);\r\n                var page = findPage(root, pageNumber);\r\n                deferred.resolve(page);\r\n                return;\r\n            })\r\n            .fail(function(exception) {\r\n                deferred.reject(exception);\r\n            })\r\n            .fail(Notification.exception);\r\n\r\n            return;\r\n        })\r\n        .fail(function(exception) {\r\n            deferred.reject(exception);\r\n            return;\r\n        })\r\n        .fail(Notification.exception);\r\n\r\n        return deferred.promise();\r\n    };\r\n\r\n    /**\r\n     * Make one or more pages visible based on the SHOW_PAGES event. The show\r\n     * pages event provides data containing which pages should be shown as well\r\n     * as the limit and offset values for loading the items for each of those pages.\r\n     *\r\n     * The renderPagesContentCallback is provided this list of data to know which\r\n     * pages to load. E.g. the data to load 2 pages might look like:\r\n     * [\r\n     *      {\r\n     *          pageNumber: 1,\r\n     *          limit: 5,\r\n     *          offset: 0\r\n     *      },\r\n     *      {\r\n     *          pageNumber: 2,\r\n     *          limit: 5,\r\n     *          offset: 5\r\n     *      }\r\n     * ]\r\n     *\r\n     * The renderPagesContentCallback should return an array of promises, one for\r\n     * each page in the pages data, that is resolved with the HTML and JS for that page.\r\n     *\r\n     * If the renderPagesContentCallback is not provided then it is assumed that\r\n     * all pages have been rendered prior to initialising this module.\r\n     *\r\n     * This function triggers the PAGES_SHOWN event after the pages have been rendered.\r\n     *\r\n     * @param {object} root The root element.\r\n     * @param {Number} pagesData The data for which pages need to be visible.\r\n     * @param {string} id A unique id for this instance.\r\n     * @param {function} renderPagesContentCallback Render pages content.\r\n     */\r\n    var showPages = function(root, pagesData, id, renderPagesContentCallback) {\r\n        var pendingPromise = new Pending('core/paged_content_pages:showPages');\r\n        var existingPages = [];\r\n        var newPageData = [];\r\n        var newPagesPromise = $.Deferred();\r\n        var shownewpage = true;\r\n        // Check which of the pages being requests have previously been rendered\r\n        // so that we only ask for new pages to be rendered by the callback.\r\n        pagesData.forEach(function(pageData) {\r\n            var pageNumber = pageData.pageNumber;\r\n            var existingPage = findPage(root, pageNumber);\r\n            if (existingPage.length) {\r\n                existingPages.push(existingPage);\r\n            } else {\r\n                newPageData.push(pageData);\r\n            }\r\n        });\r\n\r\n        if (newPageData.length && typeof renderPagesContentCallback === 'function') {\r\n            // If we have pages we haven't previously seen then ask the client code\r\n            // to render them for us by calling the callback.\r\n            var promises = renderPagesContentCallback(newPageData, {\r\n                allItemsLoaded: function(lastPageNumber) {\r\n                    PubSub.publish(id + PagedContentEvents.ALL_ITEMS_LOADED, lastPageNumber);\r\n                }\r\n            });\r\n            // After the client has finished rendering each of the pages being asked\r\n            // for then begin our rendering process to put that content into paged\r\n            // content pages.\r\n            var renderPagePromises = promises.map(function(promise, index) {\r\n                // Create our promise for when our rendering will be completed.\r\n                return renderPagePromise(root, promise, newPageData[index].pageNumber);\r\n            });\r\n            // After each of our rendering promises have been completed then we can\r\n            // give all of the new pages to the next bit of code for handling.\r\n            $.when.apply($, renderPagePromises)\r\n                .then(function() {\r\n                    var newPages = Array.prototype.slice.call(arguments);\r\n                    // Resolve the promise with the list of newly rendered pages.\r\n                    newPagesPromise.resolve(newPages);\r\n                    return;\r\n                })\r\n                .fail(function(exception) {\r\n                    newPagesPromise.reject(exception);\r\n                    return;\r\n                })\r\n                .fail(Notification.exception);\r\n        } else {\r\n            // If there aren't any pages to load then immediately resolve the promise.\r\n            newPagesPromise.resolve([]);\r\n        }\r\n\r\n        var loadingPromise = startLoading(root);\r\n        newPagesPromise.then(function(newPages) {\r\n            // Once all of the new pages have been created then add them to any\r\n            // existing pages we have.\r\n            var pagesToShow = existingPages.concat(newPages);\r\n            // Hide all existing pages.\r\n            root.find(SELECTORS.PAGE_REGION).addClass('hidden');\r\n            // Show each of the pages that were requested.;\r\n            pagesToShow.forEach(function(page) {\r\n                if (shownewpage) {\r\n                    page.removeClass('hidden');\r\n                }\r\n            });\r\n\r\n            return;\r\n        })\r\n        .then(function() {\r\n            // Let everything else know we've displayed the pages.\r\n            PubSub.publish(id + PagedContentEvents.PAGES_SHOWN, pagesData);\r\n            return;\r\n        })\r\n        .fail(Notification.exception)\r\n        .always(function() {\r\n            loadingPromise.resolve();\r\n            pendingPromise.resolve();\r\n        })\r\n        .catch();\r\n    };\r\n\r\n    /**\r\n     * Initialise the module to listen for SHOW_PAGES events and render the\r\n     * appropriate pages using the provided renderPagesContentCallback function.\r\n     *\r\n     * The renderPagesContentCallback is provided a list of data to know which\r\n     * pages to load.\r\n     * E.g. the data to load 2 pages might look like:\r\n     * [\r\n     *      {\r\n     *          pageNumber: 1,\r\n     *          limit: 5,\r\n     *          offset: 0\r\n     *      },\r\n     *      {\r\n     *          pageNumber: 2,\r\n     *          limit: 5,\r\n     *          offset: 5\r\n     *      }\r\n     * ]\r\n     *\r\n     * The renderPagesContentCallback should return an array of promises, one for\r\n     * each page in the pages data, that is resolved with the HTML and JS for that page.\r\n     *\r\n     * If the renderPagesContentCallback is not provided then it is assumed that\r\n     * all pages have been rendered prior to initialising this module.\r\n     *\r\n     * The event element is the element to listen for the paged content events on.\r\n     *\r\n     * @param {object} root The root element.\r\n     * @param {string} id A unique id for this instance.\r\n     * @param {function} renderPagesContentCallback Render pages content.\r\n     */\r\n    var init = function(root, id, renderPagesContentCallback) {\r\n        root = $(root);\r\n\r\n        PubSub.subscribe(id + PagedContentEvents.SHOW_PAGES, function(pagesData) {\r\n            showPages(root, pagesData, id, renderPagesContentCallback);\r\n        });\r\n\r\n        PubSub.subscribe(id + PagedContentEvents.SET_ITEMS_PER_PAGE_LIMIT, function() {\r\n            // If the items per page limit was changed then we need to clear our content\r\n            // the load new values based on the new limit.\r\n            root.empty();\r\n        });\r\n    };\r\n\r\n    return {\r\n        init: init,\r\n        rootSelector: SELECTORS.ROOT,\r\n    };\r\n});\r\n"],"names":["define","$","Templates","Notification","PubSub","PagedContentEvents","Pending","SELECTORS","TEMPLATES","findPage","root","pageNumber","find","showPages","pagesData","id","renderPagesContentCallback","pendingPromise","existingPages","newPageData","newPagesPromise","Deferred","forEach","pageData","existingPage","length","push","renderPagePromises","allItemsLoaded","lastPageNumber","publish","ALL_ITEMS_LOADED","map","promise","index","pagePromise","deferred","then","html","pageJS","render","page","content","appendNodeContents","resolve","fail","exception","reject","renderPagePromise","when","apply","newPages","Array","prototype","slice","call","arguments","loadingPromise","attr","visible","loadingSpinner","timerId","setTimeout","css","appendTo","always","clearTimeout","remove","removeAttr","startLoading","pagesToShow","concat","addClass","removeClass","PAGES_SHOWN","catch","init","subscribe","SHOW_PAGES","SET_ITEMS_PER_PAGE_LIMIT","empty","rootSelector"],"mappings":"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"}