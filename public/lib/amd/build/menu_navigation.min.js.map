{"version":3,"file":"menu_navigation.min.js","sources":["../src/menu_navigation.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Keyboard initialization for a given html node.\r\n *\r\n * @module     core/menu_navigation\r\n * @copyright  2021 Moodle\r\n * @author     Mathew May <mathew.solutions>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\nconst SELECTORS = {\r\n    'menuitem': '[role=\"menuitem\"]',\r\n    'tab': '[role=\"tab\"]',\r\n    'dropdowntoggle': '[data-bs-toggle=\"dropdown\"]',\r\n};\r\n\r\nlet openDropdownNode = null;\r\n\r\n/**\r\n * Small helper function to check if a given node is null or not.\r\n *\r\n * @param {HTMLElement|null} item The node that we want to compare.\r\n * @param {HTMLElement} fallback Either the first node or final node that can be focused on.\r\n * @return {HTMLElement}\r\n */\r\nconst clickErrorHandler = (item, fallback) => {\r\n    if (item !== null) {\r\n        return item;\r\n    } else {\r\n        return fallback;\r\n    }\r\n};\r\n\r\n/**\r\n * Control classes etc of the selected dropdown item and its' parent <a>\r\n *\r\n * @param {HTMLElement} src The node within the dropdown the user selected.\r\n */\r\nconst menuItemHelper = src => {\r\n    let parent;\r\n\r\n    // Do not apply any actions if the selected dropdown item is explicitly instructing to not display an active state.\r\n    if (src.dataset.disableactive) {\r\n        return;\r\n    }\r\n    // Handling for dropdown escapes.\r\n    // A bulk of the handling is already done by aria.js just add polish.\r\n    if (src.classList.contains('dropdown-item')) {\r\n        parent = src.closest('.dropdown-menu');\r\n        const dropDownToggle = document.getElementById(parent.getAttribute('aria-labelledby'));\r\n        dropDownToggle.classList.add('active');\r\n        dropDownToggle.setAttribute('tabindex', 0);\r\n    } else if (src.matches(`${SELECTORS.tab},${SELECTORS.menuitem}`) && !src.matches(SELECTORS.dropdowntoggle)) {\r\n        parent = src.parentElement.parentElement.querySelector('.dropdown-menu');\r\n    } else {\r\n        return;\r\n    }\r\n    // Remove active class from any other dropdown elements.\r\n    Array.prototype.forEach.call(parent.children, node => {\r\n        const menuItem = node.querySelector(SELECTORS.menuitem);\r\n        if (menuItem !== null) {\r\n            menuItem.classList.remove('active');\r\n            // Remove aria selection state.\r\n            menuItem.removeAttribute('aria-current');\r\n        }\r\n    });\r\n    // Set the applicable element's selection state.\r\n    if (src.getAttribute('role') === 'menuitem') {\r\n        src.setAttribute('aria-current', 'true');\r\n    }\r\n};\r\n\r\n/**\r\n * Defined keyboard event handling so we can remove listeners on nodes on resize etc.\r\n *\r\n * @param {event} e The triggering element and key presses etc.\r\n */\r\nconst keyboardListenerEvents = e => {\r\n    const src = e.srcElement;\r\n    const firstNode = e.currentTarget.firstElementChild;\r\n    const lastNode = findUsableLastNode(e.currentTarget);\r\n\r\n    // Handling for dropdown escapes.\r\n    // A bulk of the handling is already done by aria.js just add polish.\r\n    if (src.classList.contains('dropdown-item')) {\r\n        if (e.key == 'ArrowRight' ||\r\n            e.key == 'ArrowLeft') {\r\n            e.preventDefault();\r\n            if (openDropdownNode !== null) {\r\n                openDropdownNode.parentElement.click();\r\n            }\r\n        }\r\n        if (e.key == ' ' ||\r\n            e.key == 'Enter') {\r\n            e.preventDefault();\r\n\r\n            menuItemHelper(src);\r\n\r\n            if (!src.parentElement.classList.contains('dropdown')) {\r\n                src.click();\r\n            }\r\n        }\r\n    } else {\r\n        const rtl = window.right_to_left();\r\n        const arrowNext = rtl ? 'ArrowLeft' : 'ArrowRight';\r\n        const arrowPrevious = rtl ? 'ArrowRight' : 'ArrowLeft';\r\n\r\n        if (src.getAttribute('role') === 'menuitem') {\r\n            // When not rendered within a dropdown menu, handle keyboard navigation if the element is rendered as a menu item.\r\n            if (e.key == arrowNext) {\r\n                e.preventDefault();\r\n                setFocusNext(src, firstNode);\r\n            }\r\n            if (e.key == arrowPrevious) {\r\n                e.preventDefault();\r\n                setFocusPrev(src, lastNode);\r\n            }\r\n            // Let aria.js handle the dropdowns.\r\n            if (e.key == 'ArrowUp' ||\r\n                e.key == 'ArrowDown') {\r\n                openDropdownNode = src;\r\n                e.preventDefault();\r\n            }\r\n            if (e.key == 'Home') {\r\n                e.preventDefault();\r\n                setFocusHomeEnd(firstNode);\r\n            }\r\n            if (e.key == 'End') {\r\n                e.preventDefault();\r\n                setFocusHomeEnd(lastNode);\r\n            }\r\n        }\r\n\r\n        if (e.key == ' ' ||\r\n            e.key == 'Enter') {\r\n            e.preventDefault();\r\n            // Aria.js handles dropdowns etc.\r\n            if (!src.parentElement.classList.contains('dropdown')) {\r\n                src.click();\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Defined click event handling so we can remove listeners on nodes on resize etc.\r\n *\r\n * @param {event} e The triggering element and key presses etc.\r\n */\r\nconst clickListenerEvents = e => {\r\n    const src = e.srcElement;\r\n    menuItemHelper(src);\r\n};\r\n\r\n/**\r\n * The initial entry point that a given module can pass a HTMLElement.\r\n *\r\n * @param {HTMLElement} elementRoot The menu to add handlers upon.\r\n */\r\nexport default elementRoot => {\r\n    // Remove any and all instances of old listeners on the passed element.\r\n    elementRoot.removeEventListener('keydown', keyboardListenerEvents);\r\n    elementRoot.removeEventListener('click', clickListenerEvents);\r\n    // (Re)apply our event listeners to the passed element.\r\n    elementRoot.addEventListener('keydown', keyboardListenerEvents);\r\n    elementRoot.addEventListener('click', clickListenerEvents);\r\n};\r\n\r\n/**\r\n * Handle the focusing to the next element in the dropdown.\r\n *\r\n * @param {HTMLElement|null} currentNode The node that we want to take action on.\r\n * @param {HTMLElement} firstNode The backup node to focus as a last resort.\r\n */\r\nconst setFocusNext = (currentNode, firstNode) => {\r\n    const listElement = currentNode.parentElement;\r\n    const nextListItem = ((el) => {\r\n        do {\r\n            el = el.nextElementSibling;\r\n        } while (el && !el.offsetHeight); // We only work with the visible tabs.\r\n        return el;\r\n    })(listElement);\r\n    const nodeToSelect = clickErrorHandler(nextListItem, firstNode);\r\n    const parent = listElement.parentElement;\r\n    const isTabList = parent.getAttribute('role') === 'tablist';\r\n    const itemSelector = isTabList ? SELECTORS.tab : SELECTORS.menuitem;\r\n    const menuItem = nodeToSelect.querySelector(itemSelector);\r\n    menuItem.focus();\r\n};\r\n\r\n/**\r\n * Handle the focusing to the previous element in the dropdown.\r\n *\r\n * @param {HTMLElement|null} currentNode The node that we want to take action on.\r\n * @param {HTMLElement} lastNode The backup node to focus as a last resort.\r\n */\r\nconst setFocusPrev = (currentNode, lastNode) => {\r\n    const listElement = currentNode.parentElement;\r\n    const nextListItem = ((el) => {\r\n        do {\r\n            el = el.previousElementSibling;\r\n        } while (el && !el.offsetHeight); // We only work with the visible tabs.\r\n        return el;\r\n    })(listElement);\r\n    const nodeToSelect = clickErrorHandler(nextListItem, lastNode);\r\n    const parent = listElement.parentElement;\r\n    const isTabList = parent.getAttribute('role') === 'tablist';\r\n    const itemSelector = isTabList ? SELECTORS.tab : SELECTORS.menuitem;\r\n    const menuItem = nodeToSelect.querySelector(itemSelector);\r\n    menuItem.focus();\r\n};\r\n\r\n/**\r\n * Focus on either the start or end of a nav list.\r\n *\r\n * @param {HTMLElement} node The element to focus on.\r\n */\r\nconst setFocusHomeEnd = node => {\r\n    node.querySelector(SELECTORS.menuitem).focus();\r\n};\r\n\r\n/**\r\n * We need to look within the menu to find a last node we can add focus to.\r\n *\r\n * @param {HTMLElement} elementRoot Menu to find a final child node within.\r\n * @return {HTMLElement}\r\n */\r\nconst findUsableLastNode = elementRoot => {\r\n    const lastNode = elementRoot.lastElementChild;\r\n\r\n    // An example is the more menu existing but hidden on the page for the time being.\r\n    if (!lastNode.classList.contains('d-none')) {\r\n        return elementRoot.lastElementChild;\r\n    } else {\r\n        // Cast the HTMLCollection & reverse it.\r\n        const extractedNodes = Array.prototype.map.call(elementRoot.children, node => {\r\n            return node;\r\n        }).reverse();\r\n\r\n        // Get rid of any nodes we can not set focus on.\r\n        const nodesToUse = extractedNodes.filter((node => {\r\n            if (!node.classList.contains('d-none')) {\r\n                return node;\r\n            }\r\n        }));\r\n\r\n        // If we find no elements we can set focus on, fall back to the absolute first element.\r\n        if (nodesToUse.length !== 0) {\r\n            return nodesToUse[0];\r\n        } else {\r\n            return elementRoot.firstElementChild;\r\n        }\r\n    }\r\n};\r\n"],"names":["SELECTORS","openDropdownNode","clickErrorHandler","item","fallback","menuItemHelper","src","parent","dataset","disableactive","classList","contains","closest","dropDownToggle","document","getElementById","getAttribute","add","setAttribute","matches","parentElement","querySelector","Array","prototype","forEach","call","children","node","menuItem","remove","removeAttribute","keyboardListenerEvents","e","srcElement","firstNode","currentTarget","firstElementChild","lastNode","findUsableLastNode","key","preventDefault","click","rtl","window","right_to_left","arrowNext","arrowPrevious","setFocusNext","setFocusPrev","setFocusHomeEnd","clickListenerEvents","elementRoot","removeEventListener","addEventListener","currentNode","listElement","nextListItem","el","nextElementSibling","offsetHeight","nodeToSelect","itemSelector","focus","previousElementSibling","lastElementChild","nodesToUse","map","reverse","filter","length"],"mappings":"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"}