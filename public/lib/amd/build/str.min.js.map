{"version":3,"file":"str.min.js","sources":["../src/str.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Fetch and return language strings.\r\n *\r\n * @module     core/str\r\n * @copyright  2015 Damyon Wiese <damyon@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n * @since      2.9\r\n *\r\n */\r\nimport $ from 'jquery';\r\nimport Ajax from 'core/ajax';\r\nimport Config from 'core/config';\r\nimport LocalStorage from 'core/localstorage';\r\n\r\n/**\r\n * @typedef StringRequest\r\n * @type {object}\r\n * @param {string} requests.key The string identifer to fetch\r\n * @param {string} [requests.component='core'] The componet to fetch from\r\n * @param {string} [requests.lang] The language to fetch a string for. Defaults to current page language.\r\n * @param {object|string} [requests.param] The param for variable expansion in the string.\r\n */\r\n\r\n// Module cache for the promises so that we don't make multiple\r\n// unnecessary requests.\r\nlet promiseCache = [];\r\n\r\n/* eslint-disable no-restricted-properties */\r\n\r\n/**\r\n * Return a Promise that resolves to a string.\r\n *\r\n * If the string has previously been cached, then the Promise will be resolved immediately, otherwise it will be fetched\r\n * from the server and resolved when available.\r\n *\r\n * @param {string} key The language string key\r\n * @param {string} [component='core'] The language string component\r\n * @param {object|string} [param] The param for variable expansion in the string.\r\n * @param {string} [lang] The users language - if not passed it is deduced.\r\n * @return {jQuery.Promise} A jQuery Promise containing the translated string\r\n *\r\n * @example <caption>Fetching a string</caption>\r\n *\r\n * import {getString} from 'core/str';\r\n * get_string('cannotfindteacher', 'error')\r\n * .then((str) => window.console.log(str)); // Cannot find teacher\r\n */\r\n// eslint-disable-next-line camelcase\r\nexport const get_string = (key, component, param, lang) => {\r\n    return get_strings([{key, component, param, lang}])\r\n        .then(results => results[0]);\r\n};\r\n\r\n/**\r\n * Return a Promise that resolves to a string.\r\n *\r\n * If the string has previously been cached, then the Promise will be resolved immediately, otherwise it will be fetched\r\n * from the server and resolved when available.\r\n *\r\n * @param {string} key The language string key\r\n * @param {string} [component='core'] The language string component\r\n * @param {object|string} [param] The param for variable expansion in the string.\r\n * @param {string} [lang] The users language - if not passed it is deduced.\r\n * @return {Promise<string>} A native Promise containing the translated string\r\n *\r\n * @example <caption>Fetching a string</caption>\r\n *\r\n * import {getString} from 'core/str';\r\n *\r\n * getString('cannotfindteacher', 'error')\r\n * .then((str) => window.console.log(str)); // Cannot find teacher\r\n */\r\nexport const getString = (key, component, param, lang) =>\r\n    getRequestedStrings([{key, component, param, lang}])[0];\r\n\r\n/**\r\n * Make a batch request to load a set of strings.\r\n *\r\n * Any missing string will be fetched from the server.\r\n * The Promise will only be resolved once all strings are available, or an attempt has been made to fetch them.\r\n *\r\n * @param {Array.<StringRequest>} requests List of strings to fetch\r\n * @return {Promise<string[]>} A native promise containing an array of the translated strings\r\n *\r\n * @example <caption>Fetching a set of strings</caption>\r\n *\r\n * import {getStrings} from 'core/str';\r\n * getStrings([\r\n *     {\r\n *         key: 'cannotfindteacher',\r\n *         component: 'error',\r\n *     },\r\n *     {\r\n *         key: 'yes',\r\n *         component: 'core',\r\n *     },\r\n *     {\r\n *         key: 'no',\r\n *         component: 'core',\r\n *     },\r\n * ])\r\n * .then((cannotFindTeacher, yes, no) => {\r\n *     window.console.log(cannotFindTeacher); // Cannot find teacher\r\n *     window.console.log(yes); // Yes\r\n *     window.console.log(no); // No\r\n * });\r\n */\r\nexport const getStrings = (requests) => Promise.all(getRequestedStrings(requests));\r\n\r\n/**\r\n * Internal function to perform the string requests.\r\n *\r\n * @param {Array.<StringRequest>} requests List of strings to fetch\r\n * @returns {Promise[]}\r\n */\r\nconst getRequestedStrings = (requests) => {\r\n    let requestData = [];\r\n    const pageLang = Config.language;\r\n\r\n    // Helper function to construct the cache key.\r\n    const getCacheKey = ({key, component, lang = pageLang}) => `core_str/${key}/${component}/${lang}`;\r\n\r\n    const stringPromises = requests.map((request) => {\r\n        let {component, key, param, lang = pageLang} = request;\r\n        if (!component) {\r\n            component = 'core';\r\n        }\r\n\r\n        const cacheKey = getCacheKey({key, component, lang});\r\n\r\n        // Helper function to add the promise to cache.\r\n        const buildReturn = (promise) => {\r\n            // Make sure the promise cache contains our promise.\r\n            promiseCache[cacheKey] = promise;\r\n            return promise;\r\n        };\r\n\r\n        // Check if we can serve the string straight from M.str.\r\n        if (component in M.str && key in M.str[component]) {\r\n            return buildReturn(new Promise((resolve) => {\r\n                resolve(M.util.get_string(key, component, param));\r\n            }));\r\n        }\r\n\r\n        // Check if the string is in the browser's local storage.\r\n        const cached = LocalStorage.get(cacheKey);\r\n        if (cached) {\r\n            M.str[component] = {...M.str[component], [key]: cached};\r\n            return buildReturn(new Promise((resolve) => {\r\n                resolve(M.util.get_string(key, component, param));\r\n            }));\r\n        }\r\n\r\n        // Check if we've already loaded this string from the server.\r\n        if (cacheKey in promiseCache) {\r\n            return buildReturn(promiseCache[cacheKey]).then(() => {\r\n                return M.util.get_string(key, component, param);\r\n            });\r\n        } else {\r\n            // We're going to have to ask the server for the string so\r\n            // add this string to the list of requests to be sent.\r\n            return buildReturn(new Promise((resolve, reject) => {\r\n                requestData.push({\r\n                    methodname: 'core_get_string',\r\n                    args: {\r\n                        stringid: key,\r\n                        stringparams: [],\r\n                        component,\r\n                        lang,\r\n                    },\r\n                    done: (str) => {\r\n                        // When we get the response from the server\r\n                        // we should update M.str and the browser's\r\n                        // local storage before resolving this promise.\r\n                        M.str[component] = {...M.str[component], [key]: str};\r\n                        LocalStorage.set(cacheKey, str);\r\n                        resolve(M.util.get_string(key, component, param));\r\n                    },\r\n                    fail: reject\r\n                });\r\n            }));\r\n        }\r\n    });\r\n\r\n    if (requestData.length) {\r\n        // If we need to load any strings from the server then send\r\n        // off the request.\r\n        Ajax.call(requestData, true, false, false, 0, M.cfg.langrev);\r\n    }\r\n\r\n    return stringPromises;\r\n};\r\n\r\n/**\r\n * Make a batch request to load a set of strings.\r\n *\r\n * Any missing string will be fetched from the server.\r\n * The Promise will only be resolved once all strings are available, or an attempt has been made to fetch them.\r\n *\r\n * @param {Array.<StringRequest>} requests List of strings to fetch\r\n * @return {jquery.Promise<string[]>} A jquery promise containing an array of the translated strings\r\n *\r\n * @example <caption>Fetching a set of strings</caption>\r\n *\r\n * import {getStrings} from 'core/str';\r\n * get_strings([\r\n *     {\r\n *         key: 'cannotfindteacher',\r\n *         component: 'error',\r\n *     },\r\n *     {\r\n *         key: 'yes',\r\n *         component: 'core',\r\n *     },\r\n *     {\r\n *         key: 'no',\r\n *         component: 'core',\r\n *     },\r\n * ])\r\n * .then((cannotFindTeacher, yes, no) => {\r\n *     window.console.log(cannotFindTeacher); // Cannot find teacher\r\n *     window.console.log(yes); // Yes\r\n *     window.console.log(no); // No\r\n * });\r\n */\r\n// eslint-disable-next-line camelcase\r\nexport const get_strings = (requests) => {\r\n    // We need to use jQuery here because some calling code uses the\r\n    // .done handler instead of the .then handler.\r\n    return $.when.apply($, getRequestedStrings(requests))\r\n        .then((...strings) => strings);\r\n};\r\n\r\n/**\r\n * Add a list of strings to the caches.\r\n *\r\n * This function should typically only be called from core APIs to pre-cache values.\r\n *\r\n * @method cache_strings\r\n * @protected\r\n * @param {Object[]} strings List of strings to fetch\r\n * @param {string} strings.key The string identifer to fetch\r\n * @param {string} strings.value The string value\r\n * @param {string} [strings.component='core'] The componet to fetch from\r\n * @param {string} [strings.lang=Config.language] The language to fetch a string for. Defaults to current page language.\r\n */\r\n// eslint-disable-next-line camelcase\r\nexport const cache_strings = (strings) => {\r\n    strings.forEach(({key, component, value, lang = Config.language}) => {\r\n        const cacheKey = ['core_str', key, component, lang].join('/');\r\n\r\n        // Check M.str caching.\r\n        if (!(component in M.str) || !(key in M.str[component])) {\r\n            if (!(component in M.str)) {\r\n                M.str[component] = {};\r\n            }\r\n\r\n            M.str[component][key] = value;\r\n        }\r\n\r\n        // Check local storage.\r\n        if (!LocalStorage.get(cacheKey)) {\r\n            LocalStorage.set(cacheKey, value);\r\n        }\r\n\r\n        // Check the promises cache.\r\n        if (!(cacheKey in promiseCache)) {\r\n            promiseCache[cacheKey] = $.Deferred().resolve(value).promise();\r\n        }\r\n    });\r\n};\r\n/* eslint-enable no-restricted-properties */\r\n"],"names":["promiseCache","key","component","param","lang","get_strings","then","results","getRequestedStrings","requests","Promise","all","requestData","pageLang","Config","language","stringPromises","map","request","cacheKey","_ref","getCacheKey","buildReturn","promise","M","str","resolve","util","get_string","cached","LocalStorage","get","reject","push","methodname","args","stringid","stringparams","done","set","fail","length","call","cfg","langrev","$","when","apply","strings","forEach","_ref2","value","join","Deferred"],"mappings":";;;;;;;;;uVAwCIA,aAAe,uBAuBO,CAACC,IAAKC,UAAWC,MAAOC,OACvCC,YAAY,CAAC,CAACJ,IAAAA,IAAKC,UAAAA,UAAWC,MAAAA,MAAOC,KAAAA,QACvCE,MAAKC,SAAWA,QAAQ,wBAsBR,CAACN,IAAKC,UAAWC,MAAOC,OAC7CI,oBAAoB,CAAC,CAACP,IAAAA,IAAKC,UAAAA,UAAWC,MAAAA,MAAOC,KAAAA,QAAQ,uBAkC9BK,UAAaC,QAAQC,IAAIH,oBAAoBC,iBAQlED,oBAAuBC,eACrBG,YAAc,SACZC,SAAWC,gBAAOC,SAKlBC,eAAiBP,SAASQ,KAAKC,cAC7BhB,UAACA,UAADD,IAAYA,IAAZE,MAAiBA,MAAjBC,KAAwBA,KAAOS,UAAYK,QAC1ChB,YACDA,UAAY,cAGViB,SARUC,CAAAA,WAACnB,IAACA,IAADC,UAAMA,UAANE,KAAiBA,KAAOS,wCAA0BZ,gBAAOC,sBAAaE,OAQtEiB,CAAY,CAACpB,IAAAA,IAAKC,UAAAA,UAAWE,KAAAA,OAGxCkB,YAAeC,UAEjBvB,aAAamB,UAAYI,QAClBA,YAIPrB,aAAasB,EAAEC,KAAOxB,OAAOuB,EAAEC,IAAIvB,kBAC5BoB,YAAY,IAAIZ,SAASgB,UAC5BA,QAAQF,EAAEG,KAAKC,WAAW3B,IAAKC,UAAWC,kBAK5C0B,OAASC,sBAAaC,IAAIZ,iBAC5BU,QACAL,EAAEC,IAAIvB,WAAa,IAAIsB,EAAEC,IAAIvB,YAAaD,KAAM4B,QACzCP,YAAY,IAAIZ,SAASgB,UAC5BA,QAAQF,EAAEG,KAAKC,WAAW3B,IAAKC,UAAWC,aAK9CgB,YAAYnB,aACLsB,YAAYtB,aAAamB,WAAWb,MAAK,IACrCkB,EAAEG,KAAKC,WAAW3B,IAAKC,UAAWC,SAKtCmB,YAAY,IAAIZ,SAAQ,CAACgB,QAASM,UACrCpB,YAAYqB,KAAK,CACbC,WAAY,kBACZC,KAAM,CACFC,SAAUnC,IACVoC,aAAc,GACdnC,UAAAA,UACAE,KAAAA,MAEJkC,KAAOb,MAIHD,EAAEC,IAAIvB,WAAa,IAAIsB,EAAEC,IAAIvB,YAAaD,KAAMwB,2BACnCc,IAAIpB,SAAUM,KAC3BC,QAAQF,EAAEG,KAAKC,WAAW3B,IAAKC,UAAWC,SAE9CqC,KAAMR,uBAMlBpB,YAAY6B,sBAGPC,KAAK9B,aAAa,GAAM,GAAO,EAAO,EAAGY,EAAEmB,IAAIC,SAGjD5B,gBAoCEX,YAAeI,UAGjBoC,gBAAEC,KAAKC,MAAMF,gBAAGrC,oBAAoBC,WACtCH,MAAK,yCAAI0C,gDAAAA,qCAAYA,mEAiBAA,UAC1BA,QAAQC,SAAQC,YAACjD,IAACA,IAADC,UAAMA,UAANiD,MAAiBA,MAAjB/C,KAAwBA,KAAOU,gBAAOC,sBAC7CI,SAAW,CAAC,WAAYlB,IAAKC,UAAWE,MAAMgD,KAAK,KAGnDlD,aAAasB,EAAEC,KAAUxB,OAAOuB,EAAEC,IAAIvB,aAClCA,aAAasB,EAAEC,MACjBD,EAAEC,IAAIvB,WAAa,IAGvBsB,EAAEC,IAAIvB,WAAWD,KAAOkD,OAIvBrB,sBAAaC,IAAIZ,iCACLoB,IAAIpB,SAAUgC,OAIzBhC,YAAYnB,eACdA,aAAamB,UAAY0B,gBAAEQ,WAAW3B,QAAQyB,OAAO5B"}