{"version":3,"file":"selector-engine.min.js","sources":["../../../src/bootstrap/dom/selector-engine.js"],"sourcesContent":["/**\r\n * --------------------------------------------------------------------------\r\n * Bootstrap dom/selector-engine.js\r\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n * --------------------------------------------------------------------------\r\n */\r\n\r\nimport { isDisabled, isVisible, parseSelector } from '../util/index'\r\n\r\nconst getSelector = element => {\r\n  let selector = element.getAttribute('data-bs-target')\r\n\r\n  if (!selector || selector === '#') {\r\n    let hrefAttribute = element.getAttribute('href')\r\n\r\n    // The only valid content that could double as a selector are IDs or classes,\r\n    // so everything starting with `#` or `.`. If a \"real\" URL is used as the selector,\r\n    // `document.querySelector` will rightfully complain it is invalid.\r\n    // See https://github.com/twbs/bootstrap/issues/32273\r\n    if (!hrefAttribute || (!hrefAttribute.includes('#') && !hrefAttribute.startsWith('.'))) {\r\n      return null\r\n    }\r\n\r\n    // Just in case some CMS puts out a full URL with the anchor appended\r\n    if (hrefAttribute.includes('#') && !hrefAttribute.startsWith('#')) {\r\n      hrefAttribute = `#${hrefAttribute.split('#')[1]}`\r\n    }\r\n\r\n    selector = hrefAttribute && hrefAttribute !== '#' ? hrefAttribute.trim() : null\r\n  }\r\n\r\n  return selector ? selector.split(',').map(sel => parseSelector(sel)).join(',') : null\r\n}\r\n\r\nconst SelectorEngine = {\r\n  find(selector, element = document.documentElement) {\r\n    return [].concat(...Element.prototype.querySelectorAll.call(element, selector))\r\n  },\r\n\r\n  findOne(selector, element = document.documentElement) {\r\n    return Element.prototype.querySelector.call(element, selector)\r\n  },\r\n\r\n  children(element, selector) {\r\n    return [].concat(...element.children).filter(child => child.matches(selector))\r\n  },\r\n\r\n  parents(element, selector) {\r\n    const parents = []\r\n    let ancestor = element.parentNode.closest(selector)\r\n\r\n    while (ancestor) {\r\n      parents.push(ancestor)\r\n      ancestor = ancestor.parentNode.closest(selector)\r\n    }\r\n\r\n    return parents\r\n  },\r\n\r\n  prev(element, selector) {\r\n    let previous = element.previousElementSibling\r\n\r\n    while (previous) {\r\n      if (previous.matches(selector)) {\r\n        return [previous]\r\n      }\r\n\r\n      previous = previous.previousElementSibling\r\n    }\r\n\r\n    return []\r\n  },\r\n  // TODO: this is now unused; remove later along with prev()\r\n  next(element, selector) {\r\n    let next = element.nextElementSibling\r\n\r\n    while (next) {\r\n      if (next.matches(selector)) {\r\n        return [next]\r\n      }\r\n\r\n      next = next.nextElementSibling\r\n    }\r\n\r\n    return []\r\n  },\r\n\r\n  focusableChildren(element) {\r\n    const focusables = [\r\n      'a',\r\n      'button',\r\n      'input',\r\n      'textarea',\r\n      'select',\r\n      'details',\r\n      '[tabindex]',\r\n      '[contenteditable=\"true\"]'\r\n    ].map(selector => `${selector}:not([tabindex^=\"-\"])`).join(',')\r\n\r\n    return this.find(focusables, element).filter(el => !isDisabled(el) && isVisible(el))\r\n  },\r\n\r\n  getSelectorFromElement(element) {\r\n    const selector = getSelector(element)\r\n\r\n    if (selector) {\r\n      return SelectorEngine.findOne(selector) ? selector : null\r\n    }\r\n\r\n    return null\r\n  },\r\n\r\n  getElementFromSelector(element) {\r\n    const selector = getSelector(element)\r\n\r\n    return selector ? SelectorEngine.findOne(selector) : null\r\n  },\r\n\r\n  getMultipleElementsFromSelector(element) {\r\n    const selector = getSelector(element)\r\n\r\n    return selector ? SelectorEngine.find(selector) : []\r\n  }\r\n}\r\n\r\nexport default SelectorEngine\r\n"],"names":["getSelector","element","selector","getAttribute","hrefAttribute","includes","startsWith","split","trim","map","sel","join","SelectorEngine","find","document","documentElement","concat","Element","prototype","querySelectorAll","call","findOne","querySelector","children","filter","child","matches","parents","ancestor","parentNode","closest","push","prev","previous","previousElementSibling","next","nextElementSibling","focusableChildren","focusables","this","el","getSelectorFromElement","getElementFromSelector","getMultipleElementsFromSelector"],"mappings":"gMASMA,YAAcC,cACdC,SAAWD,QAAQE,aAAa,sBAE/BD,UAAyB,MAAbA,SAAkB,KAC7BE,cAAgBH,QAAQE,aAAa,YAMpCC,gBAAmBA,cAAcC,SAAS,OAASD,cAAcE,WAAW,YACxE,KAILF,cAAcC,SAAS,OAASD,cAAcE,WAAW,OAC3DF,yBAAoBA,cAAcG,MAAM,KAAK,KAG/CL,SAAWE,eAAmC,MAAlBA,cAAwBA,cAAcI,OAAS,YAGtEN,SAAWA,SAASK,MAAM,KAAKE,KAAIC,MAAO,wBAAcA,OAAMC,KAAK,KAAO,MAG7EC,eAAiB,CACrBC,KAAKX,cAAUD,+DAAUa,SAASC,sBACzB,GAAGC,UAAUC,QAAQC,UAAUC,iBAAiBC,KAAKnB,QAASC,YAGvEmB,QAAQnB,cAAUD,+DAAUa,SAASC,uBAC5BE,QAAQC,UAAUI,cAAcF,KAAKnB,QAASC,WAGvDqB,SAAQ,CAACtB,QAASC,WACT,GAAGc,UAAUf,QAAQsB,UAAUC,QAAOC,OAASA,MAAMC,QAAQxB,YAGtEyB,QAAQ1B,QAASC,gBACTyB,QAAU,OACZC,SAAW3B,QAAQ4B,WAAWC,QAAQ5B,eAEnC0B,UACLD,QAAQI,KAAKH,UACbA,SAAWA,SAASC,WAAWC,QAAQ5B,iBAGlCyB,SAGTK,KAAK/B,QAASC,cACR+B,SAAWhC,QAAQiC,4BAEhBD,UAAU,IACXA,SAASP,QAAQxB,gBACZ,CAAC+B,UAGVA,SAAWA,SAASC,6BAGf,IAGTC,KAAKlC,QAASC,cACRiC,KAAOlC,QAAQmC,wBAEZD,MAAM,IACPA,KAAKT,QAAQxB,gBACR,CAACiC,MAGVA,KAAOA,KAAKC,yBAGP,IAGTC,kBAAkBpC,eACVqC,WAAa,CACjB,IACA,SACA,QACA,WACA,SACA,UACA,aACA,4BACA7B,KAAIP,oBAAeA,oCAAiCS,KAAK,YAEpD4B,KAAK1B,KAAKyB,WAAYrC,SAASuB,QAAOgB,MAAO,qBAAWA,MAAO,oBAAUA,OAGlFC,uBAAuBxC,eACfC,SAAWF,YAAYC,gBAEzBC,UACKU,eAAeS,QAAQnB,UAAYA,SAGrC,MAGTwC,uBAAuBzC,eACfC,SAAWF,YAAYC,gBAEtBC,SAAWU,eAAeS,QAAQnB,UAAY,MAGvDyC,gCAAgC1C,eACxBC,SAAWF,YAAYC,gBAEtBC,SAAWU,eAAeC,KAAKX,UAAY,kBAIvCU"}