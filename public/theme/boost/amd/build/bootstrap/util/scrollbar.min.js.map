{"version":3,"file":"scrollbar.min.js","sources":["../../../src/bootstrap/util/scrollbar.js"],"sourcesContent":["/**\r\n * --------------------------------------------------------------------------\r\n * Bootstrap util/scrollBar.js\r\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n * --------------------------------------------------------------------------\r\n */\r\n\r\nimport Manipulator from '../dom/manipulator'\r\nimport SelectorEngine from '../dom/selector-engine'\r\nimport { isElement } from './index'\r\n\r\n/**\r\n * Constants\r\n */\r\n\r\nconst SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top'\r\nconst SELECTOR_STICKY_CONTENT = '.sticky-top'\r\nconst PROPERTY_PADDING = 'padding-right'\r\nconst PROPERTY_MARGIN = 'margin-right'\r\n\r\n/**\r\n * Class definition\r\n */\r\n\r\nclass ScrollBarHelper {\r\n  constructor() {\r\n    this._element = document.body\r\n  }\r\n\r\n  // Public\r\n  getWidth() {\r\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes\r\n    const documentWidth = document.documentElement.clientWidth\r\n    return Math.abs(window.innerWidth - documentWidth)\r\n  }\r\n\r\n  hide() {\r\n    const width = this.getWidth()\r\n    this._disableOverFlow()\r\n    // give padding to element to balance the hidden scrollbar width\r\n    this._setElementAttributes(this._element, PROPERTY_PADDING, calculatedValue => calculatedValue + width)\r\n    // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth\r\n    this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, calculatedValue => calculatedValue + width)\r\n    this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, calculatedValue => calculatedValue - width)\r\n  }\r\n\r\n  reset() {\r\n    this._resetElementAttributes(this._element, 'overflow')\r\n    this._resetElementAttributes(this._element, PROPERTY_PADDING)\r\n    this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING)\r\n    this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN)\r\n  }\r\n\r\n  isOverflowing() {\r\n    return this.getWidth() > 0\r\n  }\r\n\r\n  // Private\r\n  _disableOverFlow() {\r\n    this._saveInitialAttribute(this._element, 'overflow')\r\n    this._element.style.overflow = 'hidden'\r\n  }\r\n\r\n  _setElementAttributes(selector, styleProperty, callback) {\r\n    const scrollbarWidth = this.getWidth()\r\n    const manipulationCallBack = element => {\r\n      if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {\r\n        return\r\n      }\r\n\r\n      this._saveInitialAttribute(element, styleProperty)\r\n      const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty)\r\n      element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`)\r\n    }\r\n\r\n    this._applyManipulationCallback(selector, manipulationCallBack)\r\n  }\r\n\r\n  _saveInitialAttribute(element, styleProperty) {\r\n    const actualValue = element.style.getPropertyValue(styleProperty)\r\n    if (actualValue) {\r\n      Manipulator.setDataAttribute(element, styleProperty, actualValue)\r\n    }\r\n  }\r\n\r\n  _resetElementAttributes(selector, styleProperty) {\r\n    const manipulationCallBack = element => {\r\n      const value = Manipulator.getDataAttribute(element, styleProperty)\r\n      // We only want to remove the property if the value is `null`; the value can also be zero\r\n      if (value === null) {\r\n        element.style.removeProperty(styleProperty)\r\n        return\r\n      }\r\n\r\n      Manipulator.removeDataAttribute(element, styleProperty)\r\n      element.style.setProperty(styleProperty, value)\r\n    }\r\n\r\n    this._applyManipulationCallback(selector, manipulationCallBack)\r\n  }\r\n\r\n  _applyManipulationCallback(selector, callBack) {\r\n    if (isElement(selector)) {\r\n      callBack(selector)\r\n      return\r\n    }\r\n\r\n    for (const sel of SelectorEngine.find(selector, this._element)) {\r\n      callBack(sel)\r\n    }\r\n  }\r\n}\r\n\r\nexport default ScrollBarHelper\r\n"],"names":["constructor","_element","document","body","getWidth","documentWidth","documentElement","clientWidth","Math","abs","window","innerWidth","hide","width","this","_disableOverFlow","_setElementAttributes","calculatedValue","reset","_resetElementAttributes","isOverflowing","_saveInitialAttribute","style","overflow","selector","styleProperty","callback","scrollbarWidth","_applyManipulationCallback","element","getComputedStyle","getPropertyValue","setProperty","Number","parseFloat","actualValue","setDataAttribute","value","Manipulator","getDataAttribute","removeDataAttribute","removeProperty","callBack","sel","SelectorEngine","find"],"mappings":"ycAyBEA,mBACOC,SAAWC,SAASC,KAI3BC,iBAEQC,cAAgBH,SAASI,gBAAgBC,mBACxCC,KAAKC,IAAIC,OAAOC,WAAaN,eAGtCO,aACQC,MAAQC,KAAKV,gBACdW,wBAEAC,sBAAsBF,KAAKb,SAvBX,iBAuBuCgB,iBAAmBA,gBAAkBJ,aAE5FG,sBA3BsB,oDAEN,iBAyBgDC,iBAAmBA,gBAAkBJ,aACrGG,sBA3BuB,cAER,gBAyBiDC,iBAAmBA,gBAAkBJ,QAG5GK,aACOC,wBAAwBL,KAAKb,SAAU,iBACvCkB,wBAAwBL,KAAKb,SA/Bb,sBAgChBkB,wBAlCsB,oDAEN,sBAiChBA,wBAlCuB,cAER,gBAmCtBC,uBACSN,KAAKV,WAAa,EAI3BW,wBACOM,sBAAsBP,KAAKb,SAAU,iBACrCA,SAASqB,MAAMC,SAAW,SAGjCP,sBAAsBQ,SAAUC,cAAeC,gBACvCC,eAAiBb,KAAKV,gBAWvBwB,2BAA2BJ,UAVHK,aACvBA,UAAYf,KAAKb,UAAYS,OAAOC,WAAakB,QAAQtB,YAAcoB,2BAItEN,sBAAsBQ,QAASJ,qBAC9BR,gBAAkBP,OAAOoB,iBAAiBD,SAASE,iBAAiBN,eAC1EI,QAAQP,MAAMU,YAAYP,wBAAkBC,SAASO,OAAOC,WAAWjB,4BAM3EI,sBAAsBQ,QAASJ,qBACvBU,YAAcN,QAAQP,MAAMS,iBAAiBN,eAC/CU,kCACUC,iBAAiBP,QAASJ,cAAeU,aAIzDhB,wBAAwBK,SAAUC,oBAa3BG,2BAA2BJ,UAZHK,gBACrBQ,MAAQC,qBAAYC,iBAAiBV,QAASJ,eAEtC,OAAVY,4BAKQG,oBAAoBX,QAASJ,eACzCI,QAAQP,MAAMU,YAAYP,cAAeY,QALvCR,QAAQP,MAAMmB,eAAehB,kBAWnCG,2BAA2BJ,SAAUkB,cAC/B,oBAAUlB,UACZkB,SAASlB,mBAIN,MAAMmB,OAAOC,wBAAeC,KAAKrB,SAAUV,KAAKb,UACnDyC,SAASC"}